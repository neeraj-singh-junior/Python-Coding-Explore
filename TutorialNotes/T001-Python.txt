'y''
-------------------------------------------------------------------------------------
-> Title: PyNotes Diary
-> Author: @neeraj-singh-jr
-> Status: Ongoing
-> Created: 03.09.2022
-> Updated: 21.11.2022
-> Summary: Notes indices are as follows (**** pending)
-------------------------------------------------------------------------------------
-> Q057 : Decorator in Python;;
-> Q056 : Date and Time (datetime) Module;;
-> Q055 : Deque in collection module;;
-> Q054 : Name Tuples (namedtuple) in collections module;;
-> Q053 : Ordered Dictionary;;
-> Q052 : Difference list vs [];
-> Q051 : Collection Module;;
-> Q050 : Exception Handling;;
-> Q049 : List or Variable Destructuring;;
-> Q048 : String Helpers Methods;;
-> Q047 : Dictionary and Operation;;
-> Q046 : Set and Operation;;
-> Q045 : List and Operations;;
-> Q044 : Padding Number using F-String;;
-> Q043 : Join() vs Format() in Python;;
-> Q042 : Python Conventions;;
-> Q041 : Python Operator Precedance;;
-> Q040 : Hashing vs Encryption;;
-> Q039 : Asyncio Module in Python;;
-> Q038 : Arrays in Python;;
-> Q037 : Method Overloading and Operator Overloading;;
-> Q036 : Switch alternative in python;;
**** Q035 : Disassember Package using DIS package;;
**** Q034 : Access Python Source Code and Byte Code ;;
-> Q033 : ABCMeta, AbstractClass, abstractmethod in ABC package;;
-> Q032 : Variable arguments *args and **vargs in python;;
-> Q031 : Finding and Installing Packages;;
-> Q030 : Default Dict in Python;;
-> Q029 : Explicit string type at definition of literals;;
-> Q028 : Builtins Error and Exception;;
-> Q027 : Mutable and Immutable data types;;
-> Q026 : Explicit string type at definition of literals;;
-> Q025 : Python first class objects;;
-> Q024 : Python main() function;;
-> Q023 : Identify bugs and performing static analysis in python;;
-> Q022 : Global Interpreter Lock;;
-> Q021 : Lambda function in Python;;
-> Q020 : Module vs Packages in Python;;
-> Q019 : Inheritance in Python;;t
-> Q018 : Access Specifiers used in python;;
-> Q017 : Access Parent Class using Child class;;
-> Q016 : Python Pickling vs UnPickling;;
-> Q015 : Class Compositon Vs Inheritance;;
**** Q014 : Class Composition in Python;;
-> Q013 : @classmethod() vs @staticmethod();;
-> Q012 : Magic Method __str__() vs __repr__();;
-> Q011 : Set Variable LowerBound and UpperBound;;
-> Q010 : Create a Generator Class;;
-> Q009 : Iterators Vs Iterables Vs Generators in python;;
-> Q008 : Iterators in python;;
-> Q007 : Generators in python;;
-> Q006 : Type Hinting;;
-> Q005 : Copy in python;;
-> Q004 : Python arrays;;
-> Q003 : LAMBDA in python;;
-> Q002 : Comprehension in python;;
-> Q001 : Decorators in python;;
-------------------------------------------------------------------------------------
'''

###---PYTHON NOTES : BEGINNING 

-------------------------------------------------------------------------------------
-> Q057 : Decorator in Python;;

Sometimes we might want to run some code at the beginning and at end of a
function. 

While effective, we would have to wrap any function/code we want to measure
with time.time() statements. 

We can avoid such repetition using decorators and implement the same in a much
cleaner way.

for eg, // EXAMPLE WITHOUT DECORATOR
import time

def hello_world():
  print("Hello World")

if __name__ == "__main__":
    start = time.time()
    hello_world()
    end = time.time()
    print(f"Time taken : {end - start} seconds")


Decorators are basically functions. They help us run code before and after
other functions. Ideally, you can think of them as wrappers for other
functions.

//---------------------------------- EXAMPLE 1: DECORATOR EXAMPLES;

For eg, # BASIC EXAMPLE 1
import time

def hello_world():
  print("Hello World")

def measure_time(another_function):     # <-- Decorator function
  start = time.time()
  result = another_function()           # <-- Original function called
  end = time.time()
  print(f"Execution Time : {end - start} seconds")
  return result                         # <-- Result of original function returned

measure_time(hello_world)

for eg, # BASIC EXAMPLE 2
# Create function encrypt to encrypt the string returned from send_message
# Store the result in message

def encrypt(func):
  res = func()
  return [ord(char) for char in res]

def send_message():
  return "Tango, Charlie, Alpha"

message = encrypt(send_message)

print(message)
# OUTPUT :
[84, 97, 110, 103, 111, 44, 32, 67, 104, 97, 114, 108, 105, 101, 44, 32, 65, 108, 112, 104, 97]

//---------------------------------- EXAMPLE 2: DECORATOR AS ANNOTATION;

Python provides a cleaner and shorter way to represent decorators by using
the @ symbol.

for eg, # Annotations;
impdef measure_time(another_function):
  start = time.time()
  result = another_function()
  end = time.time()
  print(f"Time Measured : {end - start} seconds")
  return result

@measure_time           # <-- wraps hello_world in measure_time decorator
def hello_world():
  print("Hello World")

# OUTPUT :
Time Measured : 5.936622619628906e-05 seconds

EXPLANATION : An issue however, is that python runs measure_time()
(hello_world) without an explicit call or calling automatically, which is
something we might not want. 

To avoid such automatic calling scenario, we used the nested function.

//----------------------------------- EXAMPLE 3: NESTED FUNCTION;

Re-define above method using the nested function !!!

for eg,
from time import time

def runtime(main):
  def wrapper():
    start = time()
    main()
    end = time()
    print(f"runtime : {end - start} seconds")
  return wrapper  # Return the memory reference of the wrapper method defination;
  
@runtime
def greeting():
  print("Hello World")
  
greeting()    # MAIN ENTERY POINT;

# OUTPUT : 
Hello World
runtime : 3.337860107421875e-06 seconds

EXPLANATION :  The only change that we have made is that we have added a
nested function called wrapper() and moved the code within it. measure_time
() returns this wrapper function to the caller.

If we run the code snippet now, you will notice measure_time() is not being
called implicitly. Instead, we will have to call hello_world(), which will
internally call the code from wrapper() within the measure_time decorator.

for eg, # Practice Example (Redefine BASIC EXAMPLE 2)
# MESSAGE ENCYRPTION PROBLEM;

def encrypt(func):
  def wrapper():
    message = func()
    return [ord(c) for c in message]
  return wrapper
  
@encrypt
def send_message():
  return "Tango, Charlie, Alpha"

send_message()

//----------------------------------- EXAMPLE 4: DECORATIOR WITH ARGUMENT;

An buggy based example for receiving the argument inside the decorator.

import time

def measure_time(function):
  def wrapper():
    start = time.time()
    result = function() # Nested functions have access to variables from parent function
    end = time.time()
    print(f"Time taken for to execute hello is {end - start} seconds")
    return result
  return wrapper


@measure_time
def hello(name):
  print("Hello", name)

hello("Python")     # Here we've passed the "Python" as the arguments;

# OUTPUT : (Missing Parameter Error Occured)
Traceback (most recent call last):
  File "script.py", line 17, in <module>
    hello("Python")
TypeError: wrapper() takes 0 positional arguments but 1 was given

-> Real example of argument in decorator.

for eg, 

import time

def measure_time(function):
  def wrapper(*args, **kwargs): # <-- accepts arguments
    print(f"args : {args} || kwargs : {kwargs}")
    start = time.time()
    result = function(*args, **kwargs) # <-- Pass arguments to function i.e hello()
    end = time.time()
    print(f"Time taken: {end - start} seconds")
    return result
  return wrapper # <-- Notice here just memory reference to the function defination;

@measure_time
def hello(*args, **kwargs):
  print("your v-args:", args)
  print("your kw-args:", kwargs)

hello("Python", "Guido Van Rosseum", xyz=20, abc=30)

//------------------------------------ EXAMPLE 5: MULTIPLE DECORATORS;

The measure_time decorator here measures the time for running the function
twice. That is, it includes the do_twice decorator's time within it. Try
swapping the order of the decorators and see the output.

fore eg,

import time

def measure_time(function):
  '''Measures time for execution'''
  def wrapper(*args, **kwargs):
    start = time.time()
    result = function(*args, **kwargs)
    end = time.time()
    print(f"Time taken to execute print_name is {end - start} seconds")
    return result
  return wrapper


def do_twice(function):
  '''Executes the function twice'''
  def wrapper(*args, **kwargs):
    for _ in range(2):
      function(*args, **kwargs)
  return wrapper


@measure_time # <-- Decorator 1
@do_twice # <-- Decorator 2
def print_name(name):
  print(f"My name is {name}")


print_name("Eleven")

## OUTPUT :
My name is Eleven
My name is Eleven
Time taken to execute print_name is 6.9141387939453125e-06 seconds

//------------------------------------ EXAMPLE 6: DECORATOR INSIDE DECORATOR WITH ARGUMENT;

## General purpose Decorator with Decorator itself accepting arbitary arguments;;
# decorator_kwargs: kwargs are coming from decorator main (@decorator_maker);
## 1st Level Decorator;;

def decorator_maker(*args):  
    ## Decorator works likes the main;

    def decorator_main(func):
        ## Wrapper function arguments come from the main external function (employee_details);

        def wrapper(**kwargs):

            print("-----------------------------------")
            print("****|Decorator Maker Arguments|****")
            print("-----------------------------------")
            for key,value in kwargs.items():
                print(f"{key} : {value}")
            print("-----------------------------------")
            for key,value in enumerate(args, start=1):
                print(f"Hobbies {key} : {value}")
            else:
                print("-----------------------------------")
                data = func(**kwargs)
                print(f"data : {data}")

        return wrapper          ## 2nd-level-decorator > wrapper;

    return decorator_main       ## /1st-level-decorator;

@decorator_maker("Crickets", "Badminton", "Football", "Volleyball")
def student_details(**kwargs):
    return kwargs

student_details(
  "firstname" : "Neeraj",
  "middlename" : "Singh",
  "lastname" : "Junior",
  "std" : "XII"
)

# OUTPUT : 
-----------------------------------
****|Decorator Maker Arguments|****
-----------------------------------
firstname : Neeraj
middlename : Singh
lastname : Junior
std : XII
-----------------------------------
Hobbies 1 : Crickets
Hobbies 2 : Badminton
Hobbies 3 : Football
Hobbies 4 : Volleyball
-----------------------------------
data : {
  'firstname': 'Neeraj', 
  'middlename': 'Singh', 
  'lastname': 'Junior', 
  'std': 'XII'
}

-------------------------------------------------------------------------------------
-> Q056 : Date and Time (datetime) Module;;

Python provides specialized modules for working with dates and times. One of
the most popular modules for the same is the datetime module.

SYNTAX :
    from datetime import datetime
    today = datetime.now()
    print(today)               # 2022-11-21 20:01:00.791002

    # or, alternatively we can used the datetime object like this also,
    x-mas = datetime(year=2022, month=12, day=25)
    print(f"This year Christmas day comes on a {x-mas:%A}")

//---------------------------------- EXAMPLE 1;
>>> from datetime import datetime

>>> today = datetime.now()                          # 2022-11-21 20:01:00.791002  

>>> print(f"The day today is {today.day}")          # The day today is 22
>>> print(f"The month is {today.month}")            # The month is 11
>>> print(f"The year is {today.year}")              # The year is 2022
>>> print(f"The hour is {today.hour}")              # The hour is 1
>>> print(f"The minute is {today.minute}")          # The minute is 36
>>> print(f"The second is {today.second}")          # The second is 4

//---------------------------------- EXAMPLE 2: TODAYS DATE;
for eg,

from datetime import datetime

today = datetime.now()

dd = today.day
mm = today.month
yyyy = today.year

print(f"Today : {dd}-{mm}-{yyyy}")              # Today : 21-11-2022

//----------------------------------- EXAMPLE 3: HUMAN READABLE DATE;

-> Human-readable formats of dates :

-----------------------------------------------------------
|   Code     |     Description             |   Example    |  
-----------------------------------------------------------
|    %d      |   day of the month          |    08        |
|    %m      |   month of the year         |    12        |
|    %y      |   year in two digits        |    93        |
|    %Y      |   year in four digits       |    1993      |
|    %a      |   abv. name of the day      |    Sun       |
|    %A      |   full name of the day      |    Sunday    |
|    %b      |   abv. name of the month    |    Dec       |
|    %B      |   full name of the month    |    December  |
|    %H      |   hour in 24h format        |    14        |
|    %I      |   hour in 12h format        |    02        |
|    %M      |   minute of the hour        |    30        |
|    %S      |   second of the minute      |    40        |
|    %p      |   AM/PM                     |    PM        |
-----------------------------------------------------------

for eg,

from datetime import datetime

today = datetime.now()

print(f"Today   : {today:%d-%m-%y}")            # Today   : 22-11-22
print(f"Today   : {today:%d-%m-%Y}")            # Today   : 22-11-2022
print(f"Time    : {today:%H::%M::%S}")          # Time    : 01::55::57
print(f"AM/PM   : {today:%p}")                  # AM/PM   : AM
print(f"Month   : {today:%b or %B}")            # Month   : Nov or November
print(f"Weekday : {today:%a or %A}")            # Weekday : Tue or Tuesday

//----------------------------------- EXAMPLE 4: DIFFERENCE IN TIME;

You can count the required days or months. By simply subtracting it from the
`datetime.now()` object

for eg,
from datetime import datetime

current_date = datetime.now()
christmas_date = datetime(year=2022, month=12, day=25)
days_left = christmas_date - current_date

print(f"Days left with Time : {days_left}")     # Days left : 32 days, 21:36:31.024657
print(f"Days left only : {days_left}")          # Days left only : 32 days

//----------------------------------- EXAMPLE 5: REPLACE VALUE IN DATETIME;

To replace any value like a year, month, date, hour, etc within the date or
time in the datetime object we can use the replace() method.

for eg,
from datetime import datetime

christmas_day = datetime(year=2022, month=12, day=25)

# can use year, month, day, hour, minute, microsecond
next_christmas = christmas_day.replace(year=2023)

time_since = next_christmas - christmas_day

print(f"Days left for X-Mas : {time_since.days}")   # Days left for X-Mas : 365

//----------------------------------- EXAMPLE 6: TIMEDELTA IN PYTHON;

Sometimes we might want to add or subtract a number of days to/from our date.
For this, we use the timedelta() function.

The timedelta object adds or removes weeks, days, and time. For example, we
could also add an hour to our time.

for eg,

from datetime import timedelta, datetime

print(f"Today: {datetime.now()}") 
# OUTPUT : Today: 2022-11-21 21:34:17.346508

# Adds two days
add_two_days = timedelta(days=+2)
print(f"Two days later: {datetime.now() + add_two_days}")
# OUTPUT : Two days later: 2022-11-23 21:34:17.346525

# Adds 1 week
add_one_week = timedelta(weeks=+1)
print(f"One week later: {datetime.now() + add_one_week}")
# OUTPUT : One week later: 2022-11-28 21:34:17.346531

# Subracts 1 day
subtract_one_day = timedelta(days=-1)
print(f"Yesterday: {datetime.now() + subtract_one_day}")
# OUTPUT : Yesterday: 2022-11-20 21:54:19.012421

next_two_year = timedelta(days=365*2)
print(f"next year : {datetime.now() + next_two_year}")
# next year : 2024-11-20 21:54:19.012424


-------------------------------------------------------------------------------------
-> Q055 : Deque in collection module;;

A deque is a combination of a stack and a queue data structure. It basically
implements the First In First Out (Queue) and First In Last Out
(Stack) policies internally.

It is similar to a list wherein we can add and remove elements. However, a
deque is much faster when adding or removing elements compared to a list. At
the same time, it is slower when accessing elements, as you can only access
the ends of the queue.

SYNTAX :
    from collections import deque

    que = deque([1,2,3,4,5])
    print(que)

//------------------------------ EXAMPLE 1
>>> from collections import deque

>>> nums = [x for x in range(6)]
>>> print(nums)                         # [0, 1, 2, 3, 4, 5]
>>> que = deque(nums)
>>> print(que)                          # deque([0, 1, 2, 3, 4, 5])
>>> que.append(6)
>>> print(que)                          # deque([0, 1, 2, 3, 4, 5, 6])
>>> print(que.pop())                    # 6
>>> print(que)                          # deque([0, 1, 2, 3, 4, 5])
>>> print(que.popleft())                # 0
>>> print(que)                          # deque([1, 2, 3, 4, 5])
>>> que.appendleft(10)
>>> print(que)                          # deque([10, 1, 2, 3, 4, 5])


-------------------------------------------------------------------------------------
-> Q054 : Name Tuples (namedtuple) in collections module;;

A named tuple is a variant of a tuple whose values can be accessed by a given
attribute instead of indices.

SYNTAX : 
    from collections import namedtuple

    variable-name = namedtuple('name-of-tuple', ['attribute_1', 'attribute_2'])

    # Sake of Simplicity, community define the variable-name and name-of-tuple
    # of value same like below,
    Employee = namedtuple('Employee', ['firstname', 'lastname', 'ecode'])

    # then access, can be easy
    stud_1 = Employee('Neeraj', 'Singh', 'BH10319')

    print(stud_1.firstname)         # Neeraj
    print(stud_1.lastname)          # Singh
    print(stud_1.ecode)             # BH10319

    # Above namedtuple can be defined like this,
    # e = namedtuple('Employee', ['firstname', 'lastname', 'ecode'])
    # stud_1 = e('Neeraj', 'Singh', 'BH10319')
    # print(stud_1.firstname)         # Neeraj

for eg,

//------------------------------------ EXAMPLE 1

from collections import namedtuple

Person = namedtuple('Person', ['name', 'age', 'place'])
person = Person("Jonathan", 34, "Goa, India")

print(f"{person.name} is {person.age} years old coming from {person.place}.")


//------------------------------------ EXAMPLE 2
from collections import namedtuple

# Create a list of named tuples of planets with the given csv data

csv_data = "Jupiter, 69911\nSaturn, 58232 km\nUranus, 25362 km\nNeptune, 
24622 km\nEarth, 6371 km\nVenus, 6052 km\nMars, 3390 km\nMercury, 2440 km"

# Instantiate named tuple of planet with name and radius

Planet = namedtuple('Planet', ['name','radius'])
planet_list = []

for line in csv_data.split('\n'):
  name, radius = line.split(', ')
  # Create instance of planet tuple
  planet_tuple = Planet(name, radius)
  planet_list.append(planet_tuple)
  
for planet in planet_list:
  print(f"The radius of {planet.name} is {planet.radius}")

# OUTPUT :-
The radius of Jupiter is 69911
The radius of Saturn is 58232 km
The radius of Uranus is 25362 km
The radius of Neptune is 24622 km
The radius of Earth is 6371 km
The radius of Venus is 6052 km
The radius of Mars is 3390 km
The radius of Mercury is 2440 km


-------------------------------------------------------------------------------------
-> Q052 : Difference list vs [];

here, [] is just returned the location of the stored objects. but list
() convert the old object to the new object as list.

for eg,
>>> a = (1,2,3)         
>>> b = (4,5,6)
>>> c = [a] + [b]
>>> print(c)
[(1, 2, 3), (4, 5, 6)]
>>> c = list(a) + list(b)
>>> print(c)
[1, 2, 3, 4, 5, 6]


-------------------------------------------------------------------------------------
-> Q051 : Collection Module;;

Python provides a number of utilities and storage methods that can help us
store our data in the most effective way. Many of these utilities are
available in the collections module.

For a defaultdict the default value is usually not really a value, it a
factory: a method that generates a new value.

SYNTAX : 

    from collections import defaultdict

    dictionary = defaultdict(list)     
    # here, list is a factory object or iterable objects only.
    # Other options are int, float, str, dict, tuple, set etc.


//---------------------------- EXAMPLE 1: COUNTER IMPORTS;
for eg,
>>> import collections

>>> print(collections)
<module 'collections' from '/usr/lib/python3.8/collections/__init__.py'>

>>> dir(collections)
['ChainMap', 'Counter', 'Mapping', 'MutableMapping', 'OrderedDict', 'UserDict',
'UserList', 'UserString', '_Link', '_OrderedDictItemsView', '_OrderedDictKeysView',
'_OrderedDictValuesView', '__all__', '__builtins__', '__cached__', '__doc__',
'__file__', '__getattr__', '__loader__', '__name__', '__package__', '__path__',
'__spec__', '_chain', '_collections_abc', '_count_elements', '_eq', '_heapq',
'_iskeyword', '_itemgetter', '_proxy', '_recursive_repr', '_repeat', '_starmap',
'_sys', '_tuplegetter', 'abc', 'defaultdict', 'deque', 'namedtuple']

//---------------------------- EXAMPLE 2: COUNTER MODULE;
from collections import Counter


>>> from collections import Counter
>>> string = "hello"
>>> c = Counter(string)
>>> print(c)
Counter({'l': 2, 'h': 1, 'e': 1, 'o': 1})

//----------------------------- EXAMPLE 3: MOST COMMON MODULE;

-- most_common(n=None) method of collections.Counter instance --
List the n most common elements and their counts from the most
common to the least. If n is None, then list all element counts.
    
>>> Counter('abracadabra').most_common(3)
[('a', 5), ('b', 2), ('r', 2)]

for eg, 

from collections import Counter

string = '''Peter Piper picked a peck of pickled peppers
A peck of pickled peppers Peter Piper picked
If Peter Piper picked a peck of pickled peppers
Where’s the peck of pickled peppers Peter Piper picked?'''

c = Counter(string.split())
print(c.most_common(3))

# OUTPUT:
[('Peter', 4), ('Piper', 4), ('peck', 4)]

//-------------------------------- EXAMPLE 4: DEFAULT DICTIONARY

The collections module also provides a variant of a dictionary called Default
Dictionary. A default dictionary pre initializes the values in a dictionary
to a certain type.

for eg,
string = '''Peter Piper picked a peck of pickled peppers
A peck of pickled peppers Peter Piper picked
If Peter Piper picked a peck of pickled peppers
Where’s the peck of pickled peppers Peter Piper picked?'''

# CASE 1: Without default dict when non-existing key insertion;
position_mapping = {}       # normal dictionary;
words = string.split()

for position, word in enumerate(words, start=1):
  if word in position_mapping:
    position_mapping[word].append(position)
  else:
    position_mapping[word] = [position]

print(position_mapping)

# OUTPUT:
{'Peter': [1, 14, 18, 32], 'Piper': [2, 15, 19, 33], 'picked': [3, 16, 20], 
'a': [4, 21], 'peck': [5, 10, 22, 28], 'of': [6, 11, 23, 29], 
'pickled': [7, 12, 24, 30], 'peppers': [8, 13, 25, 31], 'A': [9], 'If': [17], 
'Where’s': [26], 'the': [27], 'picked?': [34]}


# CASE 2: With default dict implementation; 
position_mapping = defaultdict(list())  # Other options are int, float, str, dict, tuple, set etc.
words = string.split()

for pos,word in enumerate(words, start=1):
    position_mapping[word].append(pos)

print(position_mapping)

# OUTPUT : 
defaultdict(<class 'list'>, {
        'Peter': [1, 14, 18, 32], 'Piper': [2, 15, 19, 33], 'picked': [3, 16,
        20], 'a': [4, 21], 'peck': [5, 10, 22, 28], 'of': [6, 11, 23,
        29], 'pickled': [7, 12, 24, 30], 'peppers': [8, 13, 25, 31], 'A':[9], 'If':
        [17], 'Where’s': [26], 'the': [27], 'picked?': [34]
    }
)

//-------------------------------- EXAMPLE 5: ORDERED DICTIONARY

An Ordered Dictionary is a variant of a dictionary that maintains the order of
the elements in the way they were added. 

For eg,
from collections import OrderedDict

data = OrderedDict()
items = ["cheese", "yoghurt", "tomatoes", "yoghurt", "onions", "milk", "milk", "cheese"]

for item in items:
  if not(item in data):
    data[item] = 1
    continue
  data[item] += 1

print(data)

# OUTPUT:
OrderedDict(
    [ ('cheese', 2), ('yoghurt', 2), ('tomatoes', 1), ('onions', 1), ('milk', 2) ]
)


-------------------------------------------------------------------------------------
-> Q050 : Exception Handling;;

Exceptions are errors thrown by Python when we try to do something which we
are not allowed to or is not possible to

Few Common Execption like, Divide by zero, Adding different types ('Hello' + 10)

for eg, 
//-------------------- EXAMPLE 1 : KEY NOT FOUND EXCEPTION;;
>>> countries_and_capitals = {"India": "Delhi"}
>>> print(countries_and_capitals["England"])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
KeyError: 'England'

//-------------------- SOLUTION CAN BE HANDLED;
try:
    country = countries_list[i]
    print(f"The capital of {country} is {countries_and_capitals[country]}")
except KeyError:  
    print(f"--- Key {countries_list[i]} does not exist ---")
except IndexError:
    print(f"--- Index {i} is not present in countries_list ---")

//-------------------- EXAMPLE 2 : VERBOSE MESSAGE;
>>> try:
...   40 / 0
... except ZeroDivisionError as e:
...   print(e)
... 
division by zero


//-------------------- EAMPLE 3 : TRY-EXCEPT-ELSE BLOCK

The Else block in a try/except statement is executed when none of the except
blocks are executed i.e no error is thrown.

for eg,
>>> countries_and_capitals = {
...   "India": "Delhi",
...   "United Kingdom": "London",
...   "Thailand": "Bangkok",
...   "Russia": "Moscow",
... }
>>> 
>>> countries_list = ["India", "Russia", "China", "Thailand"]
>>> 
>>> try:
...   country = countries_list[0]
...   capital = countries_and_capitals[country]
...   print(f"The capital of {country} is {capital}")
... except KeyError:
...   print("Key was not found in dictionary")
... except IndexError:
...   print("Index does not exist in List")
... else: # <--- Else Block
...   print("No Error Occurred")
... 
The capital of India is Delhi
No Error Occurred

//---------------------- EXAMPLE 4 : FINALLY BLOCK

The finally block in a try-except statement, contains code that will be run
irrespective of if there was an error or not i.e It will always be run.

for eg,
>>> countries_and_capitals = {
...   "India": "Delhi",
...   "United Kingdom": "London",
...   "Thailand": "Bangkok",
...   "Russia": "Moscow",
... }
>>> 
>>> countries_list = ["India", "Russia", "China", "Thailand"]
>>> 
>>> try:
...   country = countries_list[4]
...   capital = countries_and_capitals[country]
...   print(f"The capital of {country} is {capital}")
... except KeyError:
...   print("Key was not found in dictionary")
... except IndexError:
...   print("Index does not exist in List")
... else:
...   print("No Error Occured")
... finally:
...   print("Runs irrespective of occurrence of error.")
... 
Index does not exist in List
Runs irrespective of occurrence of error.


-------------------------------------------------------------------------------------
-> Q049 : List or Variable Destructuring;;

//----------------------- USAGE 1: BASIC DESTRUCTING;
For eg,
>>> animal, bird, insect = "Dog", "Eagle", "Ant"
>>> print(animal, bird, insect)
Dog Eagle Ant

//----------------------- USAGE 2: TUPLE;
for eg, 
>>> animals = ('dog', 'cat', 'elephant')
>>> print(type(animals))
<class 'tuple'>
>>> a1, a2, a3 = animals
>>> print(a1,'~', a2, '~', a3)
dog ~ cat ~ elephant
>>> print(animals)
('dog', 'cat', 'elephant')

//------------------------ USAGE 3: VARIABLE ARGUMENT;
>>> numbers = (1,2,3,4,5,6,7,8,9,10,11,12,13,14)
>>> a,b,c,*var = numbers
>>> print(a,b,c)
1 2 3
>>> print(type(var))
<class 'list'>
>>> print(var)
[4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]
>>> print(type(numbers))
<class 'tuple'>

//------------------------ USAGE 4: DICTIONARY DESTRUCTING;
>>> countries_and_capitals = {
...   "USA": "Washington D.C",
...   "India": "New Delhi",
...   "China": "Beijing",
...   "England": "London"
... }
>>> 
>>> for country, capital in countries_and_capitals.items():
...   print(f"The capital of {country} is {capital}")
... 
The capital of USA is Washington D.C
The capital of India is New Delhi
The capital of China is Beijing
The capital of England is London

//------------------------ USAGE 5: ENUMERATE FUNCTION;
>>> names = ["Ricky", "Justin", "Bob"]
>>> 
>>> for index, name in enumerate(names):
...   print(f"The value at index {index} is {name}")
... 
The value at index 0 is Ricky
The value at index 1 is Justin
The value at index 2 is Bob

//------------------------- USAGE 6: NEGATIVE NUMBER;
>>> colors = ["red", "pink", "white", "yellow", "grey", "blue"]
>>> print(f"The last element in the list is {colors[-1]}")
The last element in the list is blue

>>> print(f"The second last element in the list is {colors[-2]}")
The second last element in the list is grey

>>> print(f"The third last element in the list is {colors[-3]}")
The third last element in the list is yellow

//-------------------------- USAGE 7: SLICING
>>> colors = ["red", "pink", "white", "yellow", "grey", "blue"]
>>> print(colors[0:4])
['red', 'pink', 'white', 'yellow']
>>> print(colors[3: 6])
['yellow', 'grey', 'blue']
>>> print(colors[4:])
['grey', 'blue']
>>> print(colors[:4])
['red', 'pink', 'white', 'yellow']

//--------------------------- USAGE 8: MAP
>>> names = ["Neeraj", "Mathews", "Jack"]
>>> unames = map(lambda x: x + f"(@{x})", names)
>>> print(unames)
<map object at 0x7f7241dce430>
>>> print(list(unames))
['Neeraj(@Neeraj)', 'Mathews(@Mathews)', 'Jack(@Jack)']

//---------------------------- USAGE 9: LIST COMPREHENSION

List comprehension is an inline for loop, which can be used to quickly iterate
over and process elements of a list.

SYNTAX :-
    [(return value) for value in list if (condition)]

for eg,

// Example 1:
>>> names = ["Tom", "Bob", None, "Shirley", None, "Kajal"]
>>> filtered_names = [f"Mr.{name}" for name in names if name is not None]
>>> print(filtered_names)
['Mr.Tom', 'Mr.Bob', 'Mr.Shirley', 'Mr.Kajal']


-------------------------------------------------------------------------------------
-> Q048 : String Helpers Methods;;

###--- Join() Method : 

Just like separating words into a list using a .split(), we can also join a
list of strings into a sentence using .join().

// Example 1
characters = ["Gangadhar", "Geetha", "Kilvish", "Dr.Jackal"]
print(', '.join(characters))

# OUTPUT :
Gangadhar, Geetha, Kilvish, Dr.Jackal

// Example 2: 

characters = ["Gangadhar", "Geetha", "Kilvish", "Dr.Jackal"]
print(f"The main characters in Shaktimaan were {', '.join(characters)}")

# OUTPUT :
The main characters in Shaktimaan were Gangadhar, Geetha, Kilvish, Dr.Jackal

###--- lowercase() and uppercase() and capitalize()

Convert lowercase and uppercase of letter.

for eg, 
// lowercase 
text = "PUT YOUR HANDS IN THE AIR."
print(text.lower())
# OUTPUT:
put your hands in the air.

// uppercase
text = "put your hands in the air."
print(text.uppercase())
# OUTPUT:
PUT YOUR HANDS IN THE AIR.

// capitalize()
text = "i am the king"
print(text.capitalize())
# OUTPUT :
I am the king

// remove extra spaces from string
text = "  Cooper, this is no time for caution.  \n\n"
print(text.strip())

// find index of character in word
text = "The dishes served are Mutton, Soup, Pulav, Chicken, Salad."
i = text.find("Soup") # Returns the index if the text is found
print(f"The Index of Soup is {i}")

// count the appearance of particular letter;
i = text.count("e") # Returns -1 if the text is not found
print(f"The Index of Ice Cream is {i}")

// Replace a word;
text = "The dishes served are Mutton, Soup, Pulav, Chicken, Salad"

text = text.replace("Soup", "Curry")
print(text)
# OUTPUT :
The dishes served are Mutton, Curry, Pulav, Chicken, Salad

// Check is string is digit;
print("4532".isdigit()) # check for digit;
print("4efef".isalpha()) # check for alphabet;
print("45.32".isalphanum()) # check for alpha-numeric;

// Select Subset of string;
movie = "Spiderman: No Way Home"

# Output:
>>> print(f"The first character is {movie[0]}")
The first character is S

>>> print(f"The last character is {movie[-1]}") # gets the last character
The last character is e

>>> print(f"The length of the string is {len(movie)}")
The length of the string is 22

>>> print(movie[::-1])                                  # emoH yaW oN :namredipS
>>> print(movie[-1])                                    # e
>>> print(movie[-2])                                    # m
>>> print(movie[-7:-2])                                 # ay Ho
>>> print(movie[0:len(movie)-4])                        # Spiderman: No Way 


-------------------------------------------------------------------------------------
-> Q047 : Dictionary and Operation;;

###--- DICT :-
Python provides an in-built way of storing key-value pairs. These are called
Dictionaries and can be declared using dict() or {}.

###--- OPERATION :-

// Initialization;
>>> fruits_and_colors = {
...   "grapes": "green",
...   "apple": "red",
...   "banana": "yellow",
...   "orange": "orange"
... }
>>> print(fruits_and_colors)
{'grapes': 'green', 'apple': 'red', 'banana': 'yellow', 'orange': 'orange'}
>>> print(fruits_and_colors['apple'])
red

// or 
for k,v  in fruits_and_colors.items():
... print(f"{k} are {v} in colours")
...
grapes are green in colours
apple are red in colours
banana are yellow in colours
orange are orange in colours

// Setting Default Values;
>>> print(fruits_and_colors.get('mango', 'NOT FOUND'))
NOT FOUND

// Inserting Values;
>>> fruits_and_colors['sapodilla'] = "brown"
>>> print(fruits_and_colors)
{
    'grapes': 'green', 
    'apple': 'red', 
    'banana': 'yellow', 
    'orange': 'orange', 
    'sapodilla': 'brown'
}

// Delete Values from Dictionary;

## METHOD 1: Delete using del keyword;
## To delete a key-value pair from the dictionary we can use the del keyword.

>>> print(fruits_and_colors)
{
    'grapes': 'green', 'apple': 'red', 
    'banana': 'yellow', 'orange': 'orange', 
    'sapodilla': 'brown'
}
>>> del fruits_and_colors['apple']  
>>> print(fruits_and_colors)
{'grapes': 'green', 'banana': 'yellow', 'orange': 'orange', 'sapodilla': 'brown'}

## METHOD 2: Delete using pop keyword;
## Pop can also used for deleting element as well. Difference here is pop returned 
## the delte value. 

>>> print(fruits_and_colors)
{
    'grapes': 'green', 'banana': 'yellow', 
    'sapodilla': 'brown'
}
>>> fruit = fruits_and_colors.pop('sapodilla')
>>> print(fruits_and_colors)
{'grapes': 'green', 'banana': 'yellow'}

// Merge Dictionary using updated() method:
>>> states = {'delhi', 'goa'}
>>> states_2 = {'uttrakhand', 'uttar pradesh'}
>>> states.update(states_2)
>>> print(states)
{'uttrakhand', 'delhi', 'uttar pradesh', 'goa'}


-------------------------------------------------------------------------------------
-> Q046 : Set and Operation;;

# SET :- 
It is unqiue collection of number. It can include the numbers, string, list,
tuple, dictionary.

Set can be defined using the helper method set() or similary can be defined
using the brackets {}. But remember the brackets can't be initialized empty. 

NOTE : EMPTY BRACKETS {} IS CONSIDERED AS DICTIONARY NOT SET;

###--- OPERATIONS :-
// Initialization;
>>> a = {1,2,3,4,5}
>>> b = {1,3,5,7,9}
>>> print(a|b)
{1, 2, 3, 4, 5, 7, 9}

###--- Intersection; 
>>> print(a.intersection(b))
{1, 3, 5}
or 
>>> print(a&b)
{1, 3, 5}

// Union;
>>> print(a.union(b))
{1, 2, 3, 4, 5, 7, 9}
>>> print(a|b)
{1, 2, 3, 4, 5, 7, 9}


// Difference;
>>> print(a.difference(b))
{2, 4}
>>> print(b.difference(a))
{9, 7}
or
>>> print(a-b)
{2, 4}
>>> print(b-a)
{9, 7}

// issubset()
>>> a = {1,2,3}
>>> b = {1,2,3,4,5,6,7,8,9,10}
>>> print(a.issubset(b))
True


-------------------------------------------------------------------------------------
-> Q045 : List and Operations;;

###--- LIST :-
List :- It is a heterogeneous collection of items including... 
    a) numbers
    b) string
    c) child list
    d) child tuple 
    e) dictionary 

Tuples are similar to Lists except that they cannot be modified. We cannot add
or remove elements from a tuple once declared.

Tuples are read-only and can only be accessed or searched for elements.

We can declare a tuple using the () branckets.

###--- OPERATION : -

// Initialization;
>>> fruits = ['animal', 'grapes','guawa', 'banana','mango', 'orange']
>>> print(fruits)
['animal', 'grapes', 'guawa', 'banana', 'mango', 'orange']

// remove operation;
>>> fruits.remove('banana')
>>> print(fruits)
['animal', 'grapes', 'guawa', 'mango', 'orange']

// pop operation default;
>>> fruits.pop()
'orange'
>>> print(fruits)
['grapes', 'guawa', 'mango']

// pop operation index provided;
>>> fruits.pop(0)
'animal'
>>> print(fruits)
['grapes', 'guawa', 'mango', 'orange']

// append operation;
fruits.append('oranges')
>>> print(fruits)
['grapes', 'guawa', 'mango', 'oranges']

// Accessing list;
>>> for fruit in fruits:
...     print(fruit)
# OUTPUT 
grapes
guawa
mango
oranges

// len of list;
>>>print(len(fruits))
>>>6

// Search a List
>>> print('banana' in fruits)
False
>>> print('guawa' in fruits)
True


-------------------------------------------------------------------------------------
-> Q044 : Padding Number using F-String;

Sometimes we would like to print our numbers with a fixed length. For example,
printing military time. ie. 0900 hours, we can use the inbuilt string
formating syntax to print numbers in a fixed length.

In the example below, basically padding or inserting zero to the left of the 
number, if the number has less than 4 digits.

for eg, 

print(f"We will depart at {900:04d} hours")
We will depart at 0900 hours

print(f"We will depart at {90:04d} hours")
We will depart at 0090 hours

print(f"We will depart at {99:05d} hours")
We will depart at 00099 hours

print(f"Operative \t\t Code")
print("-----------------------------")
print(f"Elena Williams \t\t {5:03d}")
print(f"Catherine Smith \t {6:03d}")
print(f"James Bond \t\t {7:03d}")

   Operative           Code
-----------------------------
 Elena Williams         005
 Catherine Smith        006
 James Bond             007


-------------------------------------------------------------------------------------
-> Q043 : Join() vs Format() in Python;

// format() 

The Indian Space Research Organisation has launched a new mission to Mars.
After the scheduled landing of its rover: Mangal, ISRO will put out a
message, announcing to the world it's successful landing.

Create a Python program to print out the message given the details below.
Use .format() to add the variable into the text.
   
for eg, 
    # Example 0:
    >>> fname, mname, lname = "Neeraj", "Singh", "Junior"
    >>> v = "f : {0}, m: {1}, l: {2}".format(fname, mname, lname)
    >>> print(v)
    f : Neeraj, m: Singh, l: Junior

    >>> v = "f : {2}, m: {1}, l: {0}".format(fname, mname, lname)
    >>> print(v)
    f : Junior, m: Singh, l: Neeraj

    >>> v = "f : {f}, m: {m}, l: {l}".format(fname, mname, lname)
    Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    KeyError: 'f'

    >>> v = "f : {f}, m: {m}, l: {l}".format(f=fname, m=mname, l=lname)
    >>> print(v)
    f : Neeraj, m: Singh, l: Junior

    # Example 1:
    >>> var = "{0}, {1}, {2}".format("Neeraj", "Singh", "Junior")
    >>> print(var)
    Neeraj, Singh, Junior

    # Example 2:
    >>> var = "firstname : {0}, middlename : {1},lastname : {2}".format("Neeraj", "Singh", "Junior")
    >>> print(var)
    firstname : Neeraj, middlename : Singh,lastname : Junior

    # Example 3:
    >>> firstname = "Neeraj"
    >>> middlename = "Singh"
    >>> lastname = "Junior"
    >>> var = "firstname : {0}, middlename : {1}, lastname : {2}".format(firstname, middlename, lastname)
    >>> print(var)
    firstname : Neeraj, middlename : Singh, lastname : Junior


// join() :

The join() method takes all items in an iterable and joins them into one
string. A string must be specified as the separator.

for eg, 
    ###--- Example 1:
    numList = ['1', '2', '3', '4']
    print(','.join(numList))
    '1,2,3,4'

    ###--- Example 2:
    >>>''.join(['A', 'B', 'C'])
    'ABC'
    >>> ''.join({'A': 0, 'B': 0, 'C': 0}) # note that dicts are unordered
    'ACB'
    >>> '-'.join(['A', 'B', 'C'])  # '-' string is the seprator
    'A-B-C' 

    ###--- EXAMPLE 3: PRINT DATA IN TABLE FORMAT;
    headers = ["Name" ,"Age","Phone","City"]
    data = [
      ['Tom', '25', '9838572948', 'Kochi'],
      ['Bob', '29', '8273885932', 'Delhi'],
      ['Rob', '45', '9273285631', 'Miami'],
    ]

    print("-----------------------------------------------------")
    print("\t|\t".join(headers))
    print("-----------------------------------------------------")

    for record in data:
      print("\t|\t".join(record))

    # Output:
    -------------------------------------------------------------
    Name    |   Age |   Phone   |   City
    -------------------------------------------------------------
    Tom |   25  |   9838572948  |   Kochi
    Bob |   29  |   8273885932  |   Delhi
    Rob |   45  |   9273285631  |   Miami


-------------------------------------------------------------------------------------
-> Q042 : Python Conventions;

// Variable Naming Conventions;

- Tip #1: Variable names should only contain alpha numeric characters.
for eg, 
    H3LL0_W0RLD = "Hello World" # valid variable name
    $uper$t@r = "superstar" # not a valid variable

- Tip #2: Variables names cannot start with a number.
for eg, 
    oceans_12 = "movie" # valid variable name
    13_reasons_why = "series" # not a valid variable

- Tip #3: Variable names are case sensitive.
for eg, 
    ANIMAL = "cow" # valid variable name
    ANiMaL = "pig" # valid variable name
    AnIMal = "crocodile" # valid variable name

    print(ANIMAL)   # cow
    print(ANiMaL)   # pig
    print(AnIMal)   # crocodile

- Tip #4: Python variables are generally declared in snake case
for eg,
    no_of_animals = 13      # recommended
    noOfAnimals = 13        # not recommended


-------------------------------------------------------------------------------------
-> Q041 : Python Operator Precedance;;

- Operator Precedance : 
 ------------------------------
|    Operators   Priority      |
|        ()          1         |
|        **          2         |
|    *, /, //, %     3         |
|        +, -        4         |
 ------------------------------

- PRIORITIES :- 
    - () : It has the highest priority
    - ** : Exponent will be executed second after the brackets
    - *, /, //, % : They all the same priority 
    - +, - : They have the same priority.


-------------------------------------------------------------------------------------
-> Q040 : Encryption vs Hashing

ENCYRPTION : 
    
    - Encryption is a two-way function where data is passed in as plaintext and
      comes out as ciphertext, which is unreadable but the data can be decrypted
      so it is readable again
    - Encryption comes in two types: Asymmetric and Symmetric. 

        a) Asymmetric Encryption

            Encryption : Asymmetric encryption uses two different keys, a
            public and private key, for encryption and decryption. The
            private key is used to encrypt data, and is kept a secret from
            everyone but the person encrypting the data. The public key is
            available for anyone, and is used for decryption. Using
            asymmetric encryption, the authenticity of the data can be
            verified, because if the data was modified in transit, it would
            not be able to be re-encrypted with the private key

            Asymmetric Encryption Algorithms:

                1) Elliptic Curve Digital Signature Algorithm (ECDSA)
                2) Rivest-Shamir-Adleman (RSA)
                3) Diffie-Hellman
                4) Pretty Good Privacy (PGP)

        b) Symmetric Encryption : 
            
            Symmetric encryption uses the same key for both encryption and
            decryption. This type of encryption uses less processing power
            and is faster, but is less secure as only one key is used

            Symmetric Encryption Algorithms:

                1) Advanced Encryption Standard (AES)
                2) Blowfish
                3) Twofish
                4) Rivest Cipher (RC4)
                5) Data Encryption Standard (DES)

HASHING  :

    - Hashing, on the other hand, is one-way, meaning the plaintext is scrambled
      into a unique digest, through the use of a salt, that cannot be decrypted.

    -  Hashing Algorithms:

        1) Message Digest Algorithm (MD5)
        2) Secure Hashing Algorithm (SHA-1, SHA-2, SHA-3)
        3) WHIRLPOOL
        4) TIGER
        5) Cyclical Reduction Check (CRC32)

HASHING USE CASES :-

1)  One of the uses for hashing is to compare large amounts of data. Hash
values are much easier to compare than large chunks of data, as they are more
concise.

2) Hashing is also used for mapping data, as finding values using hashes is
quick, and good hashes do not overlap.

3) Hashes are used in digital signatures and to create random strings to avoid
duplication of data in databases too.

4) hashing is extremely infeasible to reverse, hashing algorithms are used on
passwords. This makes the password shorter and undiscoverable by attackers.

ENCRYPTION USE CASES :-

1)  Encryption tends to be used for encrypting data that is in transit. Data
being transmitted is data that needs to be read by the recipient only, thus
it must be sent so that an attacker cannot read it.

2) Encryption hides the data from anyone taking it in the middle of transit,
and allows only the decryption key owner to read the data

3) Encryption would be used over hashing is for storing and retrieving data in
databases, authentication methods, and other cases where data must be hidden
at rest, but retrieved later.


-------------------------------------------------------------------------------------
-> Q039: Asyncio Module in Python;;

# Thread syncrhonization;




-------------------------------------------------------------------------------------
-> Q038: Arrays in Python;;

// Syntax of array module :-
arrayIdentifierName = array(typecode, [Initializers])

for eg, 
from array import Array

arr = array(paramter type, initialize values)
print(arr)

// Array Parameters Details :-
c : character of size 1 byte
u : unicode character of size 2 bytes
w : unicode character of size 4 bytes

b : signed integer of 1 byte
B : unsigned integer of 1 byte
h : signed integer of 2 bytes
H : unsigned integer of 2 bytes
i : signed integer of 2 bytes
I : unsigned integer of 2 bytes
l : signed integer of 4 bytes
L : unsigned integer of 4 bytes

f : floating point of 4 bytes
d : floating point of 8 bytes


for eg, // Array CRUD

from array import *

arr = array(i, [1,2,3])

// append values to array
arr.append(4)       # [1,2,3,4]

print(arr)

// print array
for i in arr:
    print(i)

// insert values at array
arr.insert(4,99)

// extends from list
c = [11,12,13]
arr.extends(c)
print(arr)

// more helpers...
arr.fromlist(opts=[11,22,33])
arr.count(3)
arr.tostring()              # convert to string
arr.tolist()                # convert to list


-------------------------------------------------------------------------------------
-> Q037: Method Overloading and Operator Overloading;;




-------------------------------------------------------------------------------------
-> Q036: Switch alternative in python;;

for eg,

# Case 1: Switch case using if-else;
def switch(value):
	if(value == 1):	return value*10
	elif(value == 2): return value*20
	elif(value == 3): return value*30
	else: return value

print(switch(value=3))	# switch function in python

# Case 2: Switch using dict;
switch = {
	1: lambda: 1*10,
	2: lambda: 2*20,
	3: lambda: 3*30,
	
	
}


-------------------------------------------------------------------------------------
-> Q035: Disassember Package using DIS package;;




-------------------------------------------------------------------------------------
-> Q034: Access Python Source Code and Byte Code ;;



-------------------------------------------------------------------------------------
-> Q033: ABCMeta, AbstractClass, abstractmethod in ABC package;;

# BASIC USAGE OF ABSTRACT CLASS:-
Abstract classes are classes that are meant to be inherited but avoid 
implementing specific methods, leaving behind only method signatures that 
subclasses must implement.

Abstract classes are useful for defining and enforcing class abstractions 
at a high level, similar to the concept of interfaces in typed languages, 
without the need for method implementation.

One conceptual approach to defining an abstract class is to stub out the 
class methods, and then raise a NotImplementedError if accessed. This 
prevents children classes from accessing parent methods without overriding
them first. 

for eg, 

class Fruit:
    def check_ripeness(self):
        raise NotImplementedError("method not implemented!")

class Apple(Fruit):
    pass

a = Apple()
a.check_ripeness() # raises NotImplementedError


# ABSTRACT CLASS PACKAGE :-
Abstract base classes (ABCs) enforce what derived classes implement particular 
methods from the base class.

To understand how this works and why we should use it, let's take a look at 
an example that Van Rossum would enjoy. Let's say we have a Base class 
"MontyPython"with two methods (joke & punchline) that must be implemented by 
all derived classes.

for eg,
class MontyPython:
    def joke(self):
        raise NotImplementedError()

    def punchline(self):
        raise NotImplementedError()

class ArgumentClinic(MontyPython):
    def joke(self):
        return "Hahahahahah"
        
When we instantiate an object and call it's two methods, we'll get an error
(as expected) with the punchline() method.

 >>> sketch = ArgumentClinic() 
 >>> sketch.punchline() 
 >>> NotImplementedError 

However, this still allows us to instantiate an object of the ArgumentClinic 
class without getting an error. In fact we don't get an error until we look 
for the punchline().

This is avoided by using the Abstract Base Class (ABC) module. Let's see how
this works with the same example:

for eg,

from abc import ABCMeta, abstractmethod

class MontyPython(metaclass=ABCMeta):
    @abstractmethod
    def joke(self):
        pass

@abstractmethod
def punchline(self):
    pass

class ArgumentClinic(MontyPython):
    def joke(self):
        return "Hahahahahah"
        
This time when we try to instantiate an object from the incomplete class, we 
immediately get a TypeError!

>>> c = ArgumentClinic()
>>> TypeError: "Can't instantiate abstract class ArgumentClinic with abstract 
methods punchline"

In this case, it's easy to complete the class to avoid any TypeErrors:

for eg,
class ArgumentClinic(MontyPython):
    def joke(self):
        return "Hahahahahah"

    def punchline(self):
        return "Send in the constable!"


-------------------------------------------------------------------------------------
-> Q032: *args and **vargs in python;;

- args  : RECEIVED TUPLE
- kargs : RECIEVED DICTIONARY 

###--- KEYWORDED ARGUMENT : **kwargs


//------------------------ Usage 1:

The names args and kwargs are used by convention, they are not a part of the 
language specification. Thus, these are equivalent:

for eg, They both are same...

def func(*args, **kwargs):	# example 1
	print(args)
	print(kwargs)
	
def func(*a, **b):			# example 2
	print(a)
	print(b)


//------------------------ Usage 2:

You may not have more than one args or more than one kwargs parameters 
(however they are not required)

def func(*args1, *args2): #  example 1
	# File "<stdin>", line 1
	# def test(*args1, *args2):
	
	# SyntaxError: invalid syntax


def test(**kwargs1, **kwargs2):	# example 2
	# File "<stdin>", line 1
	# def test(**kwargs1, **kwargs2):
	
	# SyntaxError: invalid syntax


//------------------------ Usage 3: 

If any positional argument follow *args , they are keyword-only arguments
that can only be passed by name. A single star may be used instead of 
*args to force values to be keyword arguments without providing a variadic
parameter list. Keyword-only parameter lists are only available in Pytohn3


def func(a, b, *args, x, y):	# Example 1
	print(a, b, args, x, y)
	
func(1, 2, 3, 4, 5, 6)
>>> Error : Missing param x,y

def func(a,b, *args, x, y):
	print(a, b, var, b, y)
	
func(1,2,3,4,6,x=8,y=9)


//------------------------ Usage 4:

Keyworded argument should be at last of the function defination.

def func(**kwargs, *args):
# File "<stdin>", line 1
# def test(**kwargs, *args):
#
# SyntaxError: invalid syntax
	

//--------------------------- Usage 5:

Keyword arguments (also known as named arguments) are arguments that need to
be named specifically while calling the function. They don't require to be in
any order like positional arguments.

We can define keyword arguments by adding a * as the first argument to a
function. In the snippet below, we define two keyword arguments width and
length, for the area() function.

for eg,
def area(*, width, length):
  return width * length

if __name__ == "__main__":
    result = area(length=10, width=6)   # Keyworded Argument accepted only;
    print(f"The area of the rectangle is {result}")

# Example without keyworded argument in above example will result error;
for eg, 

def area(*, width, length):
  return width * length

result = area(2, 3) 

# Will throw an error, like this 
Traceback (most recent call last):
  File "script.py", line 4, in <module>
    result = area(2, 3) # Will throw an error
TypeError: area() takes 0 positional arguments but 2 were given


//------------------------ Usage 6:

We can use variable argument(*args) and keyworded argument(**kwargs) together in a 
function. 

for eg, 
def area(*args, shape="rectangle", **kwargs):  # kwargs is a variable keyword argument
  print(args)
  print(shape)
  print(kwargs)

area(8,9,10,height=6, width=8, breadth=4, shape='cuboid')

# Output : 
(8, 9, 10)
cuboid
{'height': 6, 'width': 8, 'breadth': 4}


###--- VARIABLE ARGUMENT : *args ;

args uses tuple for sending and receiving the value;

when you are using *args for sending param value to a func() param
then argument gonna unpack while calling the method and the func()
recieved individual argument.

for eg,

def func(x,y):
	print(x,y)
	
a = [1,2]
func(*a)		# x = 1, y = 2 unpack a into two variables;

a.append(3)
func(*a)		# error func() expects two agrument but 3 were given;

### kwargs using in function;

Work approach is same as in the args but kwargs received key:value
pair instead of tuple as in args;

for eg,

def func(x,y):
	print(f"x: {x} // y:{y}")

x = {'a': 10, 'b': 20}
func(**x)


Note that the length of the starred argument need to be equal to the 
number of the function's arguments.

A common python idiom is to use the unpacking operator * with the zip 
function to reverse its effects.


-------------------------------------------------------------------------------------
-> Q031: Finding and Installing Packages;

For indirect calling for the pip module if the pip module is not defined as 
inside the environment variable;

$ python -m pip install 

NOTE: for directly using pip, you need to defined it inside the environment
variable like you have done while install python;

$ pip search <query>
$ pip install <query>
$ pip uniinstall <query>
$ pip install [package_name]==x.x.x # specific version of the package
$ pip install '[package_name]>=x.x.x' # minimum version of the package

$ pip list --outdated # list outdated package;

$ pip install <package> --upgrade # Upgrading the installed packges;;

$ pip install -U pip	# upgrading pip module;;


-------------------------------------------------------------------------------------
-> Q030: Deafult Dict in Python;;

A defaultdict is a dictionary with a default value for keys, so that keys for
which no value has been explicitly defined can be accessed without errors.
defaultdict is especially useful when the values in the dictionary are
collections (lists, dicts, etc) in the sense that it does not need to be
initialized every time when a new key is used.

A defaultdict will never raise a KeyError. Any key that does not exist gets
the default value returned.

for eg, 
from collections import defaultdict

data = defaultdict(int)
nums = [1,2,3,4,4,3,3,1,2,3,4,5,6]
for num in nums:
 data[num] += 1

print(data)     # defaultdict(<class 'int'>, {1: 2, 2: 2, 3: 4, 4: 3, 5: 1, 6: 1})


-------------------------------------------------------------------------------------
-> Q028: Builtins Error and Exception;;

Built in modules contains extra functionalities.For example to get square root
of a number we need to include math module.

>>> import math
>>> math.sqrt(16) # 4.0

To know all the functions in a module we can assign the functions list to a
variable, and then print the variable.

>>> import math
>>> dir(math)

['__doc__', '__name__', '__package__', 'acos', 'acosh',
'asin', 'asinh', 'atan', 'atan2', 'atanh', 'ceil', 'copysign',
'cos', 'cosh', 'degrees', 'e', 'erf', 'erfc', 'exp', 'expm1',
'fabs', 'factorial', 'floor', 'fmod', 'frexp', 'fsum', 'gamma',
'hypot', 'isinf', 'isnan', 'ldexp', 'lgamma', 'log', 'log10',
'log1p', 'modf', 'pi', 'pow'

>>> dir(__builtins__)
[
    'ArithmeticError',
    'AssertionError',
    'AttributeError',
    'BaseException',
    'BufferError',
    'BytesWarning',
    'DeprecationWarning',
    'EOFError',
    'Ellipsis',
    'EnvironmentError',
    'Exception',
    'False',
    'FloatingPointError',
    'FutureWarning',
    'GeneratorExit',
    'IOError',
    'ImportError',
    'ImportWarning',
    'IndentationError',
    'IndexError',
    'KeyError',
    'KeyboardInterrupt',
    'LookupError',
    'MemoryError',
    'NameError',
    'None',
    'NotImplemented',
    'NotImplementedError',

    ...
]


-------------------------------------------------------------------------------------
-> Q027: Mutable and Immutable data types;;

# Immutable:
int , long , float , complex
str
bytes
tuple
frozenset

# Mutable
list
set
dict
bytearray


-------------------------------------------------------------------------------------
-> Q026: Explicit string type at definition of literals;;

With one letter labels just in front of the quotes you can tell what type of
string you want to define.

- b'foo bar' : results : bytes in Python 3, str in Python 2
- u'foo bar' : results : str in Python 3, unicode in Python 2
- 'foo bar'  : results : str
- r'foo bar' : results : so called raw string, where escaping special characters
  is not necessary, everything is taken verbatim as you typed 

for eg,
normal = 'foo\nbar'         # foo 
                            # bar
escaped = 'foo\\nbar'       # foo\nbar
raw = r'foo\nbar'           # foo\nbar


-------------------------------------------------------------------------------------
-> Q025: Python first class objects;;

It means there are no restrictions on the object's use. It's the same as any
other object.

A first class object is an entity that can be dynamically created, destroyed,
passed to a function, returned as a value, and have all the rights as other
variables in the programming language have.

Depending on the language, this can imply:

- Being expressible as an anonymous literal value
- Being storable in variables
- Being storable in data structures
- Being having an intrinsic identity (independent of any given name)
- Being comparable for equality with other entities
- Being passable as a parameter to a procedure/function
- Being returnable as the result of a procedure/function
- Being constructible at runtime
- Being printable
- Being readable
- Being transmissible among distributed processes
- Being storable outside running processes


-------------------------------------------------------------------------------------
-> Q024: Python main() function;;

In the world of programming languages, the main is considered as an entry
point of execution for a program. But in python, it is known that the
interpreter serially interprets the file line-by-line. This means that python
does not provide main() function explicitly. But this doesn't mean that we
cannot simulate the execution of main. This can be done by defining
user-defined main() function and by using the __name__ property of python
file. This __name__ variable is a special built-in variable that points to
the name of the current module. This can be done as shown below:


def main():
   print("Hi Interviewbit!")
if __name__=="__main__":
   main()


-------------------------------------------------------------------------------------
-> Q023: Shallow Copy vs Deep Copy;;

Shallow copy does the task of creating new objects storing references of
original elements. This does not undergo recursion to create copies of nested
objects. It just copies the reference details of nested objects.

Deep copy creates an independent and new copy of an object and even copies all
the nested objects of the original element recursively.


-------------------------------------------------------------------------------------
-> Q022: Global Interpreter Lock;;

Yes, there are tools like PyChecker and Pylint which are used as static
analysis and linting tools respectively. PyChecker helps find bugs in python
source code files and raises alerts for code issues and their complexity.
Pylint checks for the module’s coding standards and supports different
plugins to enable custom features to meet this requirement.


-------------------------------------------------------------------------------------
-> Q022: Global Interpreter Lock;;

GIL stands for Global Interpreter Lock. This is a mutex used for limiting
access to python objects and aids in effective thread synchronization by
avoiding deadlocks. GIL helps in achieving multitasking (and not parallel
computing). The following diagram represents how GIL works.


Based on the above diagram, there are three threads. First Thread acquires the
GIL first and starts the I/O execution. When the I/O operations are done,
thread 1 releases the acquired GIL which is then taken up by the second
thread. The process repeats and the GIL are used by different threads
alternatively until the threads have completed their execution. The threads
not having the GIL lock goes into the waiting state and resumes execution
only when it acquires the lock.


-------------------------------------------------------------------------------------
-> Q021: Lambda function in Python;;

LAMBDA functions are generally inline, anonymous functions represented by a
single expression. They are used for creating function objects during
runtime. They can accept any number of parameters. They are usually used
where functions are required only for a short period. They can be used as:

They are defined by using lambda instead of def, and return the result of the
one line of code without requiring the return statement

//----------------------------- USAGE 1 : GENERAL
for eg,

square = lambda x: x * x

print(square(3))
print(square(4))

# OUTPUT : 
9
16

The code above defines a Lambda function that takes in an input x and returns
its square. The LAMBDA is then assigned to variable square that can be called
in a similar way to a normal function.

//----------------------------- USAGE 2: MAP FUNCTION
Lambda functions are generally useful when using functions like map(). The map() 
function takes in a list and returns its modified version based on some
criteria. This criterion is passed to it as a function.

for eg,
radius = [1,2,3,4,5]
areas = map(lambda x: 3.14*x*x, radius)
print(f"areas : {list(areas)}")

//------------------------------- USAGE 3: FILTER FUNCTION
>>> numbers = (1,2,3,4,5,6,7,8,9,10)
>>> data = filter(lambda x: x % 2 == 0, numbers)
>>> print(list(data))
[2, 4, 6, 8, 10]


-------------------------------------------------------------------------------------
-> Q020: Module vs Packages in Python;;

The module is a single python file. A module can import other modules
(other python files) as objects. Whereas, a package is the folder/directory
where different sub-packages and the modules reside.

A python module is created by saving a file with the extension of .py. This
file will have classes and functions that are reusable in the code as well as
across modules.

A python package is created by following the below steps:

Create a directory and give a valid name that represents its operation. Place
modules of one kind in this directory. Create __init__.py file in this
directory. This lets python know the directory we created is a package. The
contents of this package can be imported across different modules in other
packages to reuse the functionality.


-------------------------------------------------------------------------------------
-> Q019: Inheritance in Python;;

Inheritance gives the power to a class to access all attributes and methods of
another class. It aids in code reusability and helps the developer to
maintain applications without redundant code. The class inheriting from
another class is a child class or also called a derived class. The class from
which a child class derives the members are called parent class or
superclass.

Python supports different kinds of inheritance, they are:

# Single Inheritance: Child class derives members of one parent class.

# Parent class
class ParentClass:
    def par_func(self):
         print("I am parent class function")

# Child class
class ChildClass(ParentClass):
    def child_func(self):
         print("I am child class function")

# Driver code
obj1 = ChildClass()
obj1.par_func()
obj1.child_func()


# Multi-level Inheritance: The members of the parent class, A, are inherited
  by child class which is then inherited by another child class, B. The
  features of the base class and the derived class are further inherited into
  the new derived class, C. Here, A is the grandfather class of class C.

# Parent class
class A:
   def __init__(self, a_name):
       self.a_name = a_name
   
# Intermediate class
class B(A):
   def __init__(self, b_name, a_name):
       self.b_name = b_name
       # invoke constructor of class A
       A.__init__(self, a_name)

# Child class
class C(B):
   def __init__(self,c_name, b_name, a_name):
       self.c_name = c_name
       # invoke constructor of class B
       B.__init__(self, b_name, a_name)
       
   def display_names(self):
       print("A name : ", self.a_name)
       print("B name : ", self.b_name)
       print("C name : ", self.c_name)

#  Driver code
obj1 = C('child', 'intermediate', 'parent')
print(obj1.a_name)
obj1.display_names()
 

# Multiple Inheritance: This is achieved when one child class derives members
  from more than one parent class. All features of parent classes are
  inherited in the child class.

# Parent class1
class Parent1:
   def parent1_func(self):
       print("Hi I am first Parent")

# Parent class2
class Parent2:
   def parent2_func(self):
       print("Hi I am second Parent")

# Child class
class Child(Parent1, Parent2):
   def child_func(self):
       self.parent1_func()
       self.parent2_func()

# Driver's code
obj1 = Child()
obj1.child_func()


# Hierarchical Inheritance: When a parent class is derived by more than one
  child class, it is called hierarchical inheritance.

# Base class
class A:
     def a_func(self):
         print("I am from the parent class.")

# 1st Derived class
class B(A):
     def b_func(self):
         print("I am from the first child.")

# 2nd Derived class
class C(A):
     def c_func(self):
         print("I am from the second child.")
 
# Driver's code
obj1 = B()
obj2 = C()
obj1.a_func()
obj1.b_func()    #child 1 method
obj2.a_func()
obj2.c_func()    #child 2 method


-------------------------------------------------------------------------------------
-> Q018: Access Specifiers used in python;;

Python does not make use of access specifiers specifically like private,
public, protected, etc. However, it does not derive this from any variables.
It has the concept of imitating the behaviour of variables by making use of a
single (protected) or double underscore (private) as prefixed to the variable
names. By default, the variables without prefixed underscores are public.

Example:

# to demonstrate access specifiers
class InterviewbitEmployee:
   
    # protected members
    _emp_name = None
    _age = None
    
    # private members
    __branch = None
    
    # constructor
    def __init__(self, emp_name, age, branch): 
         self._emp_name = emp_name
         self._age = age
         self.__branch = branch
    
    #public member
    def display():
        print(self._emp_name +" "+self._age+" "+self.__branch)


-------------------------------------------------------------------------------------
-> Q017: Access Parent Class using Child class;;

Following are the ways using which you can access parent class members within
a child class:

By using Parent class name: You can use the name of the parent class to access
the attributes as shown in the example below:

# Example Class;
class Parent(object):  
   # Constructor
   def __init__(self, name):
       self.name = name    
 
class Child(Parent): 
   # Constructor
   def __init__(self, name, age):
       Parent.name = name
       self.age = age
 
   def display(self):
       print(Parent.name, self.age)
 

# Driver Code
obj = Child("Interviewbit", 6)
obj.display()


By using super(): The parent class members can be accessed in child class
using the super keyword.


class Parent(object):
   # Constructor
   def __init__(self, name):
       self.name = name    
 
class Child(Parent):
   # Constructor
   def __init__(self, name, age):         
       ''' 
       In Python 3.x, we can also use super().__init__(name)
       ''' 
       super(Child, self).__init__(name)
       self.age = age
 
   def display(self):
      # Note that Parent.name cant be used 
      # here since super() is used in the constructor
      print(self.name, self.age)
  
# Driver Code
obj = Child("Interviewbit", 6)
obj.display()


-------------------------------------------------------------------------------------
-> Q016: Python Pickling vs UnPickling;;

Python library offers a feature - serialization out of the box. Serializing an
object refers to transforming it into a format that can be stored, so as to
be able to deserialize it, later on, to obtain the original object. Here, the
pickle module comes into play.

Pickling:

Pickling is the name of the serialization process in Python. Any object in
Python can be serialized into a byte stream and dumped as a file in the
memory. The process of pickling is compact but pickle objects can be
compressed further. Moreover, pickle keeps track of the objects it has
serialized and the serialization is portable across versions. The function
used for the above process is pickle.dump().

Unpickling:

Unpickling is the complete inverse of pickling. It deserializes the byte
stream to recreate the objects stored in the file and loads the object to
memory. The function used for the above process is pickle.load(). Note:
Python has another, more primitive, serialization module called marshall,
which exists primarily to support .pyc files in Python and differs
significantly from the pickle.


-------------------------------------------------------------------------------------
-> Q014: Class Composition in python;;




-------------------------------------------------------------------------------------
-> Q013: @classmethod vs @stacticmethod;;

@classmethod 

The @classmethod decorator is a built-in function decorator that is an
expression that gets evaluated after your function is defined. The result of
that evaluation shadows your function definition. A class method receives the
class as an implicit first argument, just like an instance method receives
the instance.

Syntax Python Class Method: 

class C(object):
    @classmethod
    def fun(cls, arg1, arg2, ...):
       ....
fun: function that needs to be converted into a class method
returns: a class method for function.

- A class method is a method that is bound to the class and not the object of
  the class.
- They have the access to the state of the class as it takes a class parameter
that points to the class and not the object instance.
- It can modify a class state that would apply across all the instances of the
class. For example, it can modify a class variable that will be applicable to
all the instances.

@staticmethod 

A static method does not receive an implicit first argument. A static method
is also a method that is bound to the class and not the object of the class.
This method can’t access or modify the class state. It is present in a class
because it makes sense for the method to be present in class.

Syntax Python Static Method: 

class C(object):
    @staticmethod
    def fun(arg1, arg2, ...):
        ...
returns: a static method for function fun.

# When to use the class or static method ?
- We generally use the class method to create factory methods. Factory methods
  return class objects ( similar to a constructor ) for different use cases.
- We generally use static methods to create utility functions.

for eg,
# Python program to demonstrate
# use of class method and static method.
from datetime import date
 
 
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
 
    # a class method to create a Person object by birth year.
    @classmethod
    def fromBirthYear(cls, name, year):
        return cls(name, date.today().year - year)
 
    # a static method to check if a Person is adult or not.
    @staticmethod
    def isAdult(age):
        return age > 18
 
 
person1 = Person('mayank', 21)
person2 = Person.fromBirthYear('mayank', 1996)
 
print(person1.age)
print(person2.age)
 
# print the result
print(Person.isAdult(22))

#Output:
21
25
True


-------------------------------------------------------------------------------------
-> Q012: Magic Method __str__() vs __repr__();;

In Python, the built-in str() and repr() functions both produce a textual
representation of an object.

for eg,

import datetime
today = datetime.datetime.now()
print(str(today))
print(repr(today))

# Output:
2021-10-14 10:15:31.405463          # output: __str__
datetime.datetime(2021, 10, 14, 10, 15, 31, 405463)     # output: __repr__

The difference between str() and repr() is:-
- The str() function returns a user-friendly description of an object.
- The repr() method returns a developer-friendly string representation of an object.

Working str() and repr() under the hood:-
- When you call str() on an object, it calls the special method __str__ of
the object.
- And when you call repr() on an object, it calls the special method __repr__ 
of the object.
- Also, when you call print() on an object, it calls __str__ method of the 
object. If __str__ is not implemented, the __repr__ is called as a fallback.

for eg, 

# Case 1: Without str() and repr();

class Fruit:
    def __init__(self, name):
        self.name = name

banana = Fruit("Banana")
print(banana)           

# output:
<__main__.Fruit object at 0x7f0ece0e8d00>

# Case 2: With str() and repr();

class Fruit:
    def __init__(self, name):
        self.name = name
    
    def __str__(self):
        return f'I am a {self.name}'
    
    def __repr__(self):
        return f'Fruit("{self.name}")'

banana = Fruit("Banana")
print(banana)       # output: I am a Banana


-------------------------------------------------------------------------------------
-> Q011: Set Variable LowerBound and UpperBound;;

This methods helps to set the upper and lower bound of a bound for fallback
prevention.

-> FIRST APPROACH

for eg,
>>> from sys import maxsize

>>> minValue = -maxsize
>>> maxValue = maxsize
>>> print(minValue, maxValue)

-> SECOND APPROACH 
It acts as an unbounded upper value for comparison. This is
useful for finding lowest values for something. for example, calculating path
route costs when traversing trees.

e.g. Finding the "cheapest" path in a list of options:

>>> lowest_path_cost = float('inf')
>>> # pretend that these were calculated using some worthwhile algorithm
>>> path_costs = [1, 100, 2000000000000, 50]
>>> for path in path_costs:
...   if path < lowest_path_cost:
...     lowest_path_cost = path
...
>>> lowest_path_cost
1

if you didn't have float('Inf') available to you, what value would you use for
the initial lowest_path_cost? Would 9999999 be enough -- float('Inf') removes
this guesswork.


-------------------------------------------------------------------------------------
-> Q010: Create a Generator Class;;

You're almost there, writing an Iterator class (I show a Generator at the end
of the answer), but __next__ gets called every time you call the object with
next, returning a generator object. Instead, to make your code work with the
least changes, and the fewest lines of code, use __iter__, which makes your
class instantiate an iterable (which isn't technically a generator):

class Fib:
    def __init__(self):
        self.a, self.b = 0, 1
    def __iter__(self):
        while True:
            yield self.a
            self.a, self.b = self.b, self.a+self.b
When we pass an iterable to iter(), it gives us an iterator:

>>> f = iter(Fib())
>>> for i in range(3):
...     print(next(f))
...
0
1
1

To make the class itself an iterator, it does require a __next__:

class Fib:
    def __init__(self):
        self.a, self.b = 0, 1        
    def __next__(self):
        return_value = self.a
        self.a, self.b = self.b, self.a+self.b
        return return_value
    def __iter__(self):
        return self

And now, since iter just returns the instance itself, we don't need to call
it:

>>> f = Fib()
>>> for i in range(3):
...     print(next(f))
...
0
1
1

-> Why is the value self.a not getting printed at the first place?

Here's your original code with my comments:

class Fib:
    def __init__(self):
        self.a, self.b = 0, 1
        
    def __next__(self):
        yield self.a          # yield makes .__next__() return a generator!
        self.a, self.b = self.b, self.a+self.b

f = Fib()

for i in range(3):
    print(next(f))
    
So every time you called next(f) you got the generator object that __next__
returns:

<generator object __next__ at 0x000000000A3E4F68>
<generator object __next__ at 0x000000000A3E4F68>
<generator object __next__ at 0x000000000A3E4F68>


-------------------------------------------------------------------------------------
-> Q009: Iterators Vs Iterables Vs Generators in python;;

-> Iterators:-
An object capable of returning its members one at a time. Examples of
iterables include all sequence types (such as list, str, and tuple) and some
non-sequence types like dict, file objects, and objects of any classes you
define with an __iter__() method or with a __getitem__() method that
implements Sequence semantics.

Iterables can be used in a for loop and in many other places where a sequence
is needed (zip(), map(), …). When an iterable object is passed as an argument
to the built-in function iter(), it returns an iterator for the object. This
iterator is good for one pass over the set of values. When using iterables, it
is usually not necessary to call iter() or deal with iterator objects
yourself. The for statement does that automatically for you, creating a
temporary unnamed variable to hold the iterator for the duration of the loop.
See also iterator, sequence, and generator.


-> Iterables:-
An object representing a stream of data. Repeated calls to the iterator’s
__next__() method (or passing it to the built-in function next()) return
successive items in the stream. When no more data are available a
StopIteration exception is raised instead. At this point, the iterator object
is exhausted and any further calls to its __next__() method just raise
StopIteration again. Iterators are required to have an __iter__() method that
returns the iterator object itself so every iterator is also iterable and may
be used in most places where other iterables are accepted. One notable
exception is code which attempts multiple iteration passes. A container object
(such as a list) produces a fresh new iterator each time you pass it to the
iter() function or use it in a for loop. Attempting this with an iterator will
just return the same exhausted iterator object used in the previous iteration
pass, making it appear like an empty container.


-> Generator:-
A function which returns a generator iterator. It looks like a normal function
except that it contains yield expressions for producing a series of values
usable in a for-loop or that can be retrieved one at a time with the next()
function.

Usually refers to a generator function, but may refer to a generator iterator
in some contexts. In cases where the intended meaning isn’t clear, using the
full terms avoids ambiguity.


-> Generator Iterators:-
An object created by a generator function.

Each yield temporarily suspends processing, remembering the location execution
state (including local variables and pending try-statements). When the
generator iterator resumes, it picks-up where it left-off (in contrast to
functions which start fresh on every invocation).


-------------------------------------------------------------------------------------
-> Q008: Iterators in python;;

The below is class which implements `__next__`as if it was a function using
the `yield` keyword:

class FirstHundredGenerator(object):
    def __init__(self):
        self.number = 0

    # Iterators are those which have __next__(self) function;;
    def __next__(self):
        if self.number < 100:
            current = self.number
            self.number += 1
            return current
        else:
            raise StopIteration()     ## used to stop iteration;;

gen = FirstHundredGenerator()
next(gen)  # 0
next(gen)  # 1

Notice how the object, with its property, remembers what the value of
`self.number` is at all points in time.

This object is called in Python a generator because every time the next number
is available not because it’s in a sequence, but because it is generated from
its current state (in this case, by adding 1 to `self.number`).

All objects that have this `__next__` method are called iterators. All
generators are iterators, but not the other way round.

For example, you could have an iterator on which you can call `next()`, but
that doesn’t generate its values. Instead, it could take them from a list or
from a database.

*Important*: iterators are objects which have a `__next__` method.

Here’s an example of an iterator which is not a generator:

for eg,
  class FirstFiveIterator:
    def __init__(self):
        self.numbers = [1, 2, 3, 4, 5]
        self.i = 0
    
    def __next__(self):
        if self.i < len(self.numbers):
            current = self.numbers[self.i]
            self.i += 1
            return current
        else:
            raise StopIteration()

As you can see it’s returning numbers that are not being generated; instead
they’re being returned from a list.

If we run this code though, we will get an error:


sum(FirstHundredGenerator())  # comment this line out to run the rest of the file.

or 

for i in FirstHundredGenerator():
    print(i)


And that’s because in Python, an `iterator` and an `iterable` are different
things. You can iterate over an `iterable`. The iterator is used to get the
next value (either from a sequence or generated values).

You can iterate over iterables, not over iterators.
  

-------------------------------------------------------------------------------------
-> Q007: Generator in Python;;

A generator in Python is a function that remembers the state it’s in, in
between executions.

Let’s explain with an example. Imagine you wanted to build a list of 100
numbers, like this one:

for eg,
  def hundred_numbers():
    nums = []
    i = 0
    while i < 100:
      nums.append(num)
      i += 1
    return nums

We could use list comprehension for this and the `range()` function, but for
now let’s assume that this is a cool way of doing it. We construct a list,
fill it with the first 100 numbers, and then return them.

We now have 100 numbers in a list. The entire list is in your computer’s RAM
memory, taking up an admittedly small amount of space.

If we wanted 10,000,000 numbers, the list would be substantially bigger. As
you grow the number, the amount of memory taken up by the list also grows.

A generator is used to circumvent this problem. Instead of having a list, the
first time you run the function you would get the first number (`0`). The
second time you run the function you’d get `1`. Then `2`, and so on.

You have to run the function every time you want a new number, that’s why it’s
called a “generator”. It generates numbers (or indeed strings, or anything
else you want to generate).

for eg,
  def hundred_numbers():
    num = 0
    while num < 100:
      yield num
      num += 1

The `yield` keyword is very much like a `return`, in that it gives the value
back to the caller and returns execution control to them (show this with
example run). However, the next time you run the function, execution continues
from the very next line inside the function, instead of from the top.

We could re-write the function as a list comprehension:

for eg,
  hunderd_numbers = [n for n in range(100)]

Or indeed as a generator comprehension. This is essentially the same thing,
including the `yield` statement.

hundred_numbers = (n for n in range(100))
print(next(hundred_numbers))
print(next(hundred_numbers))

print(list(hundred_numbers))

""" 
Notice that when we do the code snippet above, `next()` runs the function
once up until the `yield` (which would give you the first value). The
following `next()` runs it again, which gives you the second value. Then,
turning it into a list continues and builds a list from the remaining values
(that’s only 98 values left).

A few sections ago I printed out `range(10)` and it was a strange `range(0,
10)` thing. That’s a generator object! 
"""


-------------------------------------------------------------------------------------
-> Q006: Type Hinting in Python;;

It is used to validate the data type of the incoming argument of a function or
returning variable  from the function; 

  For eg,
  from typing import List, Dict, Tuple, Type        ## Import statement;

  def sample(x: int) -> List[Dict[key, bool]:
    res = []
    for i in range(x):
      if(i%2 == 0)
        res.append({i:True})
      else:
        res.append({i:False})

    return res            ## Output: List[Dict[int, bool]]


## Generic Types

The fundamental building blocks defined above allow to construct new types in
a generic manner. For example, Tuple can take a concrete type float and make a
concrete type Vector = Tuple[float, ...], or it can take another type UserID
and make another concrete type Registry = Tuple[UserID, ...]. Such semantics
is known as generic type constructor, it is similar to semantics of functions,
but a function takes a value and returns a value, while generic type
constructor takes a type and “returns” a type.

It is common when a particular class or a function behaves in such a type
generic manner. Consider two examples:

Container classes, such as list or dict, typically contain only values of a
particular type. Therefore, a user might want to type annotate them as such:
users = [] # type: List[UserID] users.append(UserID(42)) # OK
users.append('Some guy') # Should be rejected by the type checker

examples = {} # type: Dict[str, Any]
examples['first example'] = object() # OK
examples[2] = None                   # rejected by the type checker

The following function can take two arguments of type int and return an int,
or take two arguments of type float and return a float, etc.: 

def add(x, y):
  return x + y

add(1, 2) == 3
add('1', '2') == '12'
add(2.7, 3.5) == 6.2

To allow type annotations in situations from the first example, built-in
containers and container abstract base classes are extended with type
parameters, so that they behave as generic type constructors. Classes, that
behave as generic type constructors are called generic types. Example:

from typing import Iterable

class Task:
    ...

def work(todo_list: Iterable[Task]) -> None:
    ...

Here Iterable is a generic type that takes a concrete type Task and returns a
concrete type Iterable[Task].

Functions that behave in the type generic manner (as in second example) are
called generic functions. Type annotations of generic functions are allowed by
type variables. Their semantics with respect to generic types is somewhat
similar to semantics of parameters in functions. But one does not assign
concrete types to type variables, it is the task of a static type checker to
find their possible values and warn the user if it cannot find. Example:

def take_first(seq: Sequence[T]) -> T: # a generic function
    return seq[0]

accumulator = 0 # type: int

accumulator += take_first([1, 2, 3])   # Safe, T deduced to be int
accumulator += take_first((2.7, 3.5))  # Unsafe

Type variables are used extensively in type annotations, also internal
machinery of the type inference in type checkers is typically build on type
variables. Therefore, let us consider them in detail.


-------------------------------------------------------------------------------------

-> Q005: Copy in Python;

In Python, the assignment statement (= operator) does not copy objects.
Instead, it creates a binding between the existing object and the target
variable name. To create copies of an object in Python, we need to use the
copy module. Moreover, there are two ways of creating copies for the given
object using the copy module -

Shallow Copy is a bit-wise copy of an object. The copied object created has an
exact copy of the values in the original object. If either of the values is a
reference to other objects, just the reference addresses for the same are
copied. 

Deep Copy copies all values recursively from source to target object,
i.e. it even duplicates the objects referenced by the source object.

from copy import copy, deepcopy
list_1 = [1, 2, [3, 5], 4]
## shallow copy
list_2 = copy(list_1) 
list_2[3] = 7
list_2[2].append(6)
list_2    # output => [1, 2, [3, 5, 6], 7]
list_1    # output => [1, 2, [3, 5, 6], 4]
## deep copy
list_3 = deepcopy(list_1)
list_3[3] = 8
list_3[2].append(7)
list_3    # output => [1, 2, [3, 5, 6, 7], 8]
list_1    # output => [1, 2, [3, 5, 6], 4]


-------------------------------------------------------------------------------------
-> Q004: Python arrays;

Arrays in python can only contain elements of same data types i.e., data type
of array should be homogeneous. It is a thin wrapper around C language arrays
and consumes far less memory than lists. Lists in python can contain elements
of different data types i.e., data type of lists can be heterogeneous. It has
the disadvantage of consuming large memory.

import array

a = array.array('i', [1, 2, 3])
for i in a:
    print(i, end=' ')    #OUTPUT: 1 2 3

a = array.array('i', [1, 2, 'string'])   

#OUTPUT: TypeError: an integer is required (got type str)

a = [1, 2, 'string']

for i in a:
   print(i, end=' ')    #OUTPUT: 1 2 string


-------------------------------------------------------------------------------------
-> Q003: LAMBDA;

Lambda is an anonymous function in Python, that can accept any number of
arguments, but can only have a single expression. It is generally used in
situations requiring an anonymous function for a short time period. Lambda
functions can be used in either of the two ways:

Assigning lambda functions to a variable:
mul = lambda a, b : a * b
print(mul(2, 5))    # output => 10
Wrapping lambda functions inside another function:
def myWrapper(n):
 return lambda a : a * n
mulFive = myWrapper(5)
print(mulFive(2))    # output => 10


-------------------------------------------------------------------------------------
-> Q002: Comprehensions;

Python comprehensions, like decorators, are syntactic sugar constructs that
help build altered and filtered lists, dictionaries, or sets from a given
list, dictionary, or set. Using comprehensions saves a lot of time and code
that might be considerably more verbose (containing more lines of code). Let's
check out some examples, where comprehensions can be truly beneficial:

Performing mathematical operations on the entire list
my_list = [2, 3, 5, 7, 11]
squared_list = [x**2 for x in my_list]    # list comprehension
# output => [4 , 9 , 25 , 49 , 121]
squared_dict = {x:x**2 for x in my_list}    # dict comprehension
# output => {11: 121, 2: 4 , 3: 9 , 5: 25 , 7: 49}
Performing conditional filtering operations on the entire list
my_list = [2, 3, 5, 7, 11]
squared_list = [x**2 for x in my_list if x%2 != 0]    # list comprehension
# output => [9 , 25 , 49 , 121]
squared_dict = {x:x**2 for x in my_list if x%2 != 0}    # dict comprehension
# output => {11: 121, 3: 9 , 5: 25 , 7: 49}

Combining multiple lists into one Comprehensions allow for multiple iterators
and hence, can be used to combine multiple lists into one. 

a = [1, 2, 3]
b = [7, 8, 9]
[(x + y) for (x,y) in zip(a,b)]  # parallel iterators
# output => [8, 10, 12]
[(x,y) for x in a for y in b]    # nested iterators
# output => [(1, 7), (1, 8), (1, 9), (2, 7), (2, 8), (2, 9), (3, 7), (3, 8), (3, 9)] 

Flattening a multi-dimensional list A similar approach of nested iterators (as
above) can be applied to flatten a multi-dimensional list or work upon its
inner elements. 

my_list = [[10,20,30],[40,50,60],[70,80,90]]
flattened = [x for temp in my_list for x in temp]
# output => [10, 20, 30, 40, 50, 60, 70, 80, 90]

Note: List comprehensions have the same effect as the map method in other
languages. They follow the mathematical set builder notation rather than map
and filter functions in Python.


-------------------------------------------------------------------------------------
-> Q001: Decorators in python;; 

Decorators in Python are essentially functions that add functionality to an
existing function in Python without changing the structure of the function
itself. They are represented the @decorator_name in Python and are called in a
bottom-up fashion. For example:

# decorator function to convert to lowercase
def lowercase_decorator(function):
   def wrapper():
       func = function()
       string_lowercase = func.lower()
       return string_lowercase
   return wrapper
# decorator function to split words
def splitter_decorator(function):
   def wrapper():
       func = function()
       string_split = func.split()
       return string_split
   return wrapper
@splitter_decorator # this is executed next
@lowercase_decorator # this is executed first
def hello():
   return 'Hello World'
hello()   # output => [ 'hello' , 'world' ]

The beauty of the decorators lies in the fact that besides adding
functionality to the output of the method, they can even accept arguments for
functions and can further modify those arguments before passing it to the
function itself. The inner nested function, i.e. 'wrapper' function, plays a
significant role here. It is implemented to enforce encapsulation and thus,
keep itself hidden from the global scope.

# decorator function to capitalize names
def names_decorator(function):
   def wrapper(arg1, arg2):
       arg1 = arg1.capitalize()
       arg2 = arg2.capitalize()
       string_hello = function(arg1, arg2)
       return string_hello
   return wrapper
@names_decorator
def say_hello(name1, name2):
   return 'Hello ' + name1 + '! Hello ' + name2 + '!'
say_hello('sara', 'ansh')   # output => 'Hello Sara! Hello Ansh!'


-------------------------------------------------------------------------------------