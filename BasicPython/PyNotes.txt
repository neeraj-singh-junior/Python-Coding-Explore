'''
----------------------------------------------------------------------------------------------------
-> Title: PyNotes Diary
-> Status: Ongoing...
-> Created: 03.09.2022
-> Updated: 06.09.2022
-> Summary: Notes indices are as follows
----------------------------------------------------------------------------------------------------
-> Question 015: Class Compositon Vs Inheritance;;
-> Question 014: Class Composition in Python;;
-> Question 013: @classmethod() vs @staticmethod();;
-> Question 012: Magic Method __str__() vs __repr__();;
-> Question 011: Set Variable LowerBound and UpperBound;;
-> Question 010: Create a Generator Class;;
-> Question 009: Iterators Vs Iterables Vs Generators in python;;
-> Question 008: Iterators in python;;
-> Question 007: Generators in python;;
-> Question 006: Type Hinting;;
-> Question 005: Copy in python;;
-> Question 004: Python arrays;;
-> Question 003: LAMBDA in python;;
-> Question 002: Comprehension in python;;
-> Question 001: Decorators in python;;
----------------------------------------------------------------------------------------------------
'''
----------------------------------------------------------------------------------------------------
Question 014: Class Composition in python;;




----------------------------------------------------------------------------------------------------
Question 013: @classmethod vs @stacticmethod;;

@classmethod 

The @classmethod decorator is a built-in function decorator that is an
expression that gets evaluated after your function is defined. The result of
that evaluation shadows your function definition. A class method receives the
class as an implicit first argument, just like an instance method receives
the instance.

Syntax Python Class Method: 

class C(object):
    @classmethod
    def fun(cls, arg1, arg2, ...):
       ....
fun: function that needs to be converted into a class method
returns: a class method for function.

- A class method is a method that is bound to the class and not the object of
  the class.
- They have the access to the state of the class as it takes a class parameter
that points to the class and not the object instance.
- It can modify a class state that would apply across all the instances of the
class. For example, it can modify a class variable that will be applicable to
all the instances.

@staticmethod 

A static method does not receive an implicit first argument. A static method
is also a method that is bound to the class and not the object of the class.
This method can’t access or modify the class state. It is present in a class
because it makes sense for the method to be present in class.

Syntax Python Static Method: 

class C(object):
    @staticmethod
    def fun(arg1, arg2, ...):
        ...
returns: a static method for function fun.

# When to use the class or static method ?
- We generally use the class method to create factory methods. Factory methods
  return class objects ( similar to a constructor ) for different use cases.
- We generally use static methods to create utility functions.

for eg,
# Python program to demonstrate
# use of class method and static method.
from datetime import date
 
 
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
 
    # a class method to create a Person object by birth year.
    @classmethod
    def fromBirthYear(cls, name, year):
        return cls(name, date.today().year - year)
 
    # a static method to check if a Person is adult or not.
    @staticmethod
    def isAdult(age):
        return age > 18
 
 
person1 = Person('mayank', 21)
person2 = Person.fromBirthYear('mayank', 1996)
 
print(person1.age)
print(person2.age)
 
# print the result
print(Person.isAdult(22))

#Output:
21
25
True

----------------------------------------------------------------------------------------------------
Question 012: Magic Method __str__() vs __repr__();;

In Python, the built-in str() and repr() functions both produce a textual
representation of an object.

for eg,

import datetime
today = datetime.datetime.now()
print(str(today))
print(repr(today))

# Output:
2021-10-14 10:15:31.405463          # output: __str__
datetime.datetime(2021, 10, 14, 10, 15, 31, 405463)     # output: __repr__

The difference between str() and repr() is:-
- The str() function returns a user-friendly description of an object.
- The repr() method returns a developer-friendly string representation of an object.

Working str() and repr() under the hood:-
- When you call str() on an object, it calls the special method __str__ of
the object.
- And when you call repr() on an object, it calls the special method __repr__ 
of the object.
- Also, when you call print() on an object, it calls __str__ method of the 
object. If __str__ is not implemented, the __repr__ is called as a fallback.

for eg, 

# Case 1: Without str() and repr();

class Fruit:
    def __init__(self, name):
        self.name = name

banana = Fruit("Banana")
print(banana)           

# output:
<__main__.Fruit object at 0x7f0ece0e8d00>

# Case 2: With str() and repr();

class Fruit:
    def __init__(self, name):
        self.name = name
    
    def __str__(self):
        return f'I am a {self.name}'
    
    def __repr__(self):
        return f'Fruit("{self.name}")'

banana = Fruit("Banana")
print(banana)       # output: I am a Banana

----------------------------------------------------------------------------------------------------
Question 011: Set Variable LowerBound and UpperBound;;

This methods helps to set the upper and lower bound of a bound for fallback
prevention.

-> FIRST APPROACH

for eg,
>>> from sys import maxsize

>>> minValue = -maxsize
>>> maxValue = maxsize
>>> print(minValue, maxValue)

-> SECOND APPROACH 
It acts as an unbounded upper value for comparison. This is
useful for finding lowest values for something. for example, calculating path
route costs when traversing trees.

e.g. Finding the "cheapest" path in a list of options:

>>> lowest_path_cost = float('inf')
>>> # pretend that these were calculated using some worthwhile algorithm
>>> path_costs = [1, 100, 2000000000000, 50]
>>> for path in path_costs:
...   if path < lowest_path_cost:
...     lowest_path_cost = path
...
>>> lowest_path_cost
1

if you didn't have float('Inf') available to you, what value would you use for
the initial lowest_path_cost? Would 9999999 be enough -- float('Inf') removes
this guesswork.

----------------------------------------------------------------------------------------------------
Question 010: Create a Generator Class;;

You're almost there, writing an Iterator class (I show a Generator at the end
of the answer), but __next__ gets called every time you call the object with
next, returning a generator object. Instead, to make your code work with the
least changes, and the fewest lines of code, use __iter__, which makes your
class instantiate an iterable (which isn't technically a generator):

class Fib:
    def __init__(self):
        self.a, self.b = 0, 1
    def __iter__(self):
        while True:
            yield self.a
            self.a, self.b = self.b, self.a+self.b
When we pass an iterable to iter(), it gives us an iterator:

>>> f = iter(Fib())
>>> for i in range(3):
...     print(next(f))
...
0
1
1

To make the class itself an iterator, it does require a __next__:

class Fib:
    def __init__(self):
        self.a, self.b = 0, 1        
    def __next__(self):
        return_value = self.a
        self.a, self.b = self.b, self.a+self.b
        return return_value
    def __iter__(self):
        return self

And now, since iter just returns the instance itself, we don't need to call
it:

>>> f = Fib()
>>> for i in range(3):
...     print(next(f))
...
0
1
1

-> Why is the value self.a not getting printed at the first place?

Here's your original code with my comments:

class Fib:
    def __init__(self):
        self.a, self.b = 0, 1
        
    def __next__(self):
        yield self.a          # yield makes .__next__() return a generator!
        self.a, self.b = self.b, self.a+self.b

f = Fib()

for i in range(3):
    print(next(f))
    
So every time you called next(f) you got the generator object that __next__
returns:

<generator object __next__ at 0x000000000A3E4F68>
<generator object __next__ at 0x000000000A3E4F68>
<generator object __next__ at 0x000000000A3E4F68>


----------------------------------------------------------------------------------------------------
Question 009: Iterators Vs Iterables Vs Generators in python;;

-> Iterators:-
An object capable of returning its members one at a time. Examples of
iterables include all sequence types (such as list, str, and tuple) and some
non-sequence types like dict, file objects, and objects of any classes you
define with an __iter__() method or with a __getitem__() method that
implements Sequence semantics.

Iterables can be used in a for loop and in many other places where a sequence
is needed (zip(), map(), …). When an iterable object is passed as an argument
to the built-in function iter(), it returns an iterator for the object. This
iterator is good for one pass over the set of values. When using iterables, it
is usually not necessary to call iter() or deal with iterator objects
yourself. The for statement does that automatically for you, creating a
temporary unnamed variable to hold the iterator for the duration of the loop.
See also iterator, sequence, and generator.


-> Iterables:-
An object representing a stream of data. Repeated calls to the iterator’s
__next__() method (or passing it to the built-in function next()) return
successive items in the stream. When no more data are available a
StopIteration exception is raised instead. At this point, the iterator object
is exhausted and any further calls to its __next__() method just raise
StopIteration again. Iterators are required to have an __iter__() method that
returns the iterator object itself so every iterator is also iterable and may
be used in most places where other iterables are accepted. One notable
exception is code which attempts multiple iteration passes. A container object
(such as a list) produces a fresh new iterator each time you pass it to the
iter() function or use it in a for loop. Attempting this with an iterator will
just return the same exhausted iterator object used in the previous iteration
pass, making it appear like an empty container.


-> Generator:-
A function which returns a generator iterator. It looks like a normal function
except that it contains yield expressions for producing a series of values
usable in a for-loop or that can be retrieved one at a time with the next()
function.

Usually refers to a generator function, but may refer to a generator iterator
in some contexts. In cases where the intended meaning isn’t clear, using the
full terms avoids ambiguity.


-> Generator Iterators:-
An object created by a generator function.

Each yield temporarily suspends processing, remembering the location execution
state (including local variables and pending try-statements). When the
generator iterator resumes, it picks-up where it left-off (in contrast to
functions which start fresh on every invocation).


----------------------------------------------------------------------------------------------------
Question 008: Iterators in python;;

The below is class which implements `__next__`as if it was a function using
the `yield` keyword:

class FirstHundredGenerator(object):
    def __init__(self):
        self.number = 0

    # Iterators are those which have __next__(self) function;;
    def __next__(self):
        if self.number < 100:
            current = self.number
            self.number += 1
            return current
        else:
            raise StopIteration()     ## used to stop iteration;;

gen = FirstHundredGenerator()
next(gen)  # 0
next(gen)  # 1

Notice how the object, with its property, remembers what the value of
`self.number` is at all points in time.

This object is called in Python a generator because every time the next number
is available not because it’s in a sequence, but because it is generated from
its current state (in this case, by adding 1 to `self.number`).

All objects that have this `__next__` method are called iterators. All
generators are iterators, but not the other way round.

For example, you could have an iterator on which you can call `next()`, but
that doesn’t generate its values. Instead, it could take them from a list or
from a database.

*Important*: iterators are objects which have a `__next__` method.

Here’s an example of an iterator which is not a generator:

for eg,
  class FirstFiveIterator:
    def __init__(self):
        self.numbers = [1, 2, 3, 4, 5]
        self.i = 0
    
    def __next__(self):
        if self.i < len(self.numbers):
            current = self.numbers[self.i]
            self.i += 1
            return current
        else:
            raise StopIteration()

As you can see it’s returning numbers that are not being generated; instead
they’re being returned from a list.

If we run this code though, we will get an error:


sum(FirstHundredGenerator())  # comment this line out to run the rest of the file.

or 

for i in FirstHundredGenerator():
    print(i)


And that’s because in Python, an `iterator` and an `iterable` are different
things. You can iterate over an `iterable`. The iterator is used to get the
next value (either from a sequence or generated values).

You can iterate over iterables, not over iterators.
  
----------------------------------------------------------------------------------------------------
Question 007: Generator in Python;;

A generator in Python is a function that remembers the state it’s in, in
between executions.

Let’s explain with an example. Imagine you wanted to build a list of 100
numbers, like this one:

for eg,
  def hundred_numbers():
    nums = []
    i = 0
    while i < 100:
      nums.append(num)
      i += 1
    return nums

We could use list comprehension for this and the `range()` function, but for
now let’s assume that this is a cool way of doing it. We construct a list,
fill it with the first 100 numbers, and then return them.

We now have 100 numbers in a list. The entire list is in your computer’s RAM
memory, taking up an admittedly small amount of space.

If we wanted 10,000,000 numbers, the list would be substantially bigger. As
you grow the number, the amount of memory taken up by the list also grows.

A generator is used to circumvent this problem. Instead of having a list, the
first time you run the function you would get the first number (`0`). The
second time you run the function you’d get `1`. Then `2`, and so on.

You have to run the function every time you want a new number, that’s why it’s
called a “generator”. It generates numbers (or indeed strings, or anything
else you want to generate).

for eg,
  def hundred_numbers():
    num = 0
    while num < 100:
      yield num
      num += 1

The `yield` keyword is very much like a `return`, in that it gives the value
back to the caller and returns execution control to them (show this with
example run). However, the next time you run the function, execution continues
from the very next line inside the function, instead of from the top.

We could re-write the function as a list comprehension:

for eg,
  hunderd_numbers = [n for n in range(100)]

Or indeed as a generator comprehension. This is essentially the same thing,
including the `yield` statement.

hundred_numbers = (n for n in range(100))
print(next(hundred_numbers))
print(next(hundred_numbers))

print(list(hundred_numbers))

""" 
Notice that when we do the code snippet above, `next()` runs the function
once up until the `yield` (which would give you the first value). The
following `next()` runs it again, which gives you the second value. Then,
turning it into a list continues and builds a list from the remaining values
(that’s only 98 values left).

A few sections ago I printed out `range(10)` and it was a strange `range(0,
10)` thing. That’s a generator object! 
"""

----------------------------------------------------------------------------------------------------
Question 006: Type Hinting in Python;;

It is used to validate the data type of the incoming argument of a function or
returning variable  from the function; 

  For eg,
  from typing import List, Dict, Tuple, Type        ## Import statement;

  def sample(x: int) -> List[Dict[key, bool]:
    res = []
    for i in range(x):
      if(i%2 == 0)
        res.append({i:True})
      else:
        res.append({i:False})

    return res            ## Output: List[Dict[int, bool]]


## Generic Types

The fundamental building blocks defined above allow to construct new types in
a generic manner. For example, Tuple can take a concrete type float and make a
concrete type Vector = Tuple[float, ...], or it can take another type UserID
and make another concrete type Registry = Tuple[UserID, ...]. Such semantics
is known as generic type constructor, it is similar to semantics of functions,
but a function takes a value and returns a value, while generic type
constructor takes a type and “returns” a type.

It is common when a particular class or a function behaves in such a type
generic manner. Consider two examples:

Container classes, such as list or dict, typically contain only values of a
particular type. Therefore, a user might want to type annotate them as such:
users = [] # type: List[UserID] users.append(UserID(42)) # OK
users.append('Some guy') # Should be rejected by the type checker

examples = {} # type: Dict[str, Any]
examples['first example'] = object() # OK
examples[2] = None                   # rejected by the type checker

The following function can take two arguments of type int and return an int,
or take two arguments of type float and return a float, etc.: 

def add(x, y):
  return x + y

add(1, 2) == 3
add('1', '2') == '12'
add(2.7, 3.5) == 6.2

To allow type annotations in situations from the first example, built-in
containers and container abstract base classes are extended with type
parameters, so that they behave as generic type constructors. Classes, that
behave as generic type constructors are called generic types. Example:

from typing import Iterable

class Task:
    ...

def work(todo_list: Iterable[Task]) -> None:
    ...

Here Iterable is a generic type that takes a concrete type Task and returns a
concrete type Iterable[Task].

Functions that behave in the type generic manner (as in second example) are
called generic functions. Type annotations of generic functions are allowed by
type variables. Their semantics with respect to generic types is somewhat
similar to semantics of parameters in functions. But one does not assign
concrete types to type variables, it is the task of a static type checker to
find their possible values and warn the user if it cannot find. Example:

def take_first(seq: Sequence[T]) -> T: # a generic function
    return seq[0]

accumulator = 0 # type: int

accumulator += take_first([1, 2, 3])   # Safe, T deduced to be int
accumulator += take_first((2.7, 3.5))  # Unsafe

Type variables are used extensively in type annotations, also internal
machinery of the type inference in type checkers is typically build on type
variables. Therefore, let us consider them in detail.

----------------------------------------------------------------------------------------------------

Question 005: Copy in Python;

In Python, the assignment statement (= operator) does not copy objects.
Instead, it creates a binding between the existing object and the target
variable name. To create copies of an object in Python, we need to use the
copy module. Moreover, there are two ways of creating copies for the given
object using the copy module -

Shallow Copy is a bit-wise copy of an object. The copied object created has an
exact copy of the values in the original object. If either of the values is a
reference to other objects, just the reference addresses for the same are
copied. 

Deep Copy copies all values recursively from source to target object,
i.e. it even duplicates the objects referenced by the source object.

from copy import copy, deepcopy
list_1 = [1, 2, [3, 5], 4]
## shallow copy
list_2 = copy(list_1) 
list_2[3] = 7
list_2[2].append(6)
list_2    # output => [1, 2, [3, 5, 6], 7]
list_1    # output => [1, 2, [3, 5, 6], 4]
## deep copy
list_3 = deepcopy(list_1)
list_3[3] = 8
list_3[2].append(7)
list_3    # output => [1, 2, [3, 5, 6, 7], 8]
list_1    # output => [1, 2, [3, 5, 6], 4]

----------------------------------------------------------------------------------------------------
Question 004: Python arrays;

Arrays in python can only contain elements of same data types i.e., data type
of array should be homogeneous. It is a thin wrapper around C language arrays
and consumes far less memory than lists. Lists in python can contain elements
of different data types i.e., data type of lists can be heterogeneous. It has
the disadvantage of consuming large memory.

import array

a = array.array('i', [1, 2, 3])
for i in a:
    print(i, end=' ')    #OUTPUT: 1 2 3
a = array.array('i', [1, 2, 'string'])   #OUTPUT: TypeError: an integer is required (got type str)
a = [1, 2, 'string']
for i in a:
   print(i, end=' ')    #OUTPUT: 1 2 string

----------------------------------------------------------------------------------------------------
Question 003: LAMBDA;

Lambda is an anonymous function in Python, that can accept any number of
arguments, but can only have a single expression. It is generally used in
situations requiring an anonymous function for a short time period. Lambda
functions can be used in either of the two ways:

Assigning lambda functions to a variable:
mul = lambda a, b : a * b
print(mul(2, 5))    # output => 10
Wrapping lambda functions inside another function:
def myWrapper(n):
 return lambda a : a * n
mulFive = myWrapper(5)
print(mulFive(2))    # output => 10

----------------------------------------------------------------------------------------------------
Question 002: Comprehensions;

Python comprehensions, like decorators, are syntactic sugar constructs that
help build altered and filtered lists, dictionaries, or sets from a given
list, dictionary, or set. Using comprehensions saves a lot of time and code
that might be considerably more verbose (containing more lines of code). Let's
check out some examples, where comprehensions can be truly beneficial:

Performing mathematical operations on the entire list
my_list = [2, 3, 5, 7, 11]
squared_list = [x**2 for x in my_list]    # list comprehension
# output => [4 , 9 , 25 , 49 , 121]
squared_dict = {x:x**2 for x in my_list}    # dict comprehension
# output => {11: 121, 2: 4 , 3: 9 , 5: 25 , 7: 49}
Performing conditional filtering operations on the entire list
my_list = [2, 3, 5, 7, 11]
squared_list = [x**2 for x in my_list if x%2 != 0]    # list comprehension
# output => [9 , 25 , 49 , 121]
squared_dict = {x:x**2 for x in my_list if x%2 != 0}    # dict comprehension
# output => {11: 121, 3: 9 , 5: 25 , 7: 49}

Combining multiple lists into one Comprehensions allow for multiple iterators
and hence, can be used to combine multiple lists into one. 

a = [1, 2, 3]
b = [7, 8, 9]
[(x + y) for (x,y) in zip(a,b)]  # parallel iterators
# output => [8, 10, 12]
[(x,y) for x in a for y in b]    # nested iterators
# output => [(1, 7), (1, 8), (1, 9), (2, 7), (2, 8), (2, 9), (3, 7), (3, 8), (3, 9)] 

Flattening a multi-dimensional list A similar approach of nested iterators (as
above) can be applied to flatten a multi-dimensional list or work upon its
inner elements. 

my_list = [[10,20,30],[40,50,60],[70,80,90]]
flattened = [x for temp in my_list for x in temp]
# output => [10, 20, 30, 40, 50, 60, 70, 80, 90]

Note: List comprehensions have the same effect as the map method in other
languages. They follow the mathematical set builder notation rather than map
and filter functions in Python.


----------------------------------------------------------------------------------------------------
Question 001: Decorators in python;; 

Decorators in Python are essentially functions that add functionality to an
existing function in Python without changing the structure of the function
itself. They are represented the @decorator_name in Python and are called in a
bottom-up fashion. For example:

# decorator function to convert to lowercase
def lowercase_decorator(function):
   def wrapper():
       func = function()
       string_lowercase = func.lower()
       return string_lowercase
   return wrapper
# decorator function to split words
def splitter_decorator(function):
   def wrapper():
       func = function()
       string_split = func.split()
       return string_split
   return wrapper
@splitter_decorator # this is executed next
@lowercase_decorator # this is executed first
def hello():
   return 'Hello World'
hello()   # output => [ 'hello' , 'world' ]

The beauty of the decorators lies in the fact that besides adding
functionality to the output of the method, they can even accept arguments for
functions and can further modify those arguments before passing it to the
function itself. The inner nested function, i.e. 'wrapper' function, plays a
significant role here. It is implemented to enforce encapsulation and thus,
keep itself hidden from the global scope.

# decorator function to capitalize names
def names_decorator(function):
   def wrapper(arg1, arg2):
       arg1 = arg1.capitalize()
       arg2 = arg2.capitalize()
       string_hello = function(arg1, arg2)
       return string_hello
   return wrapper
@names_decorator
def say_hello(name1, name2):
   return 'Hello ' + name1 + '! Hello ' + name2 + '!'
say_hello('sara', 'ansh')   # output => 'Hello Sara! Hello Ansh!'

----------------------------------------------------------------------------------------------------